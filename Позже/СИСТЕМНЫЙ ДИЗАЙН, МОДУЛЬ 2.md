# Виды баз данных и критерии выбора

## Введение

Основные темы:

- Виды и классы баз данных: реляционные, графовые, NoSQL, документо-ориентированные, колонночные, key-value, time-series, blob storage.
- Индексы, транзакции, брокеры сообщений (кратко).
- Альтернативные способы хранения данных.
- Критерии выбора базы данных и примеры применения.

**Аналогия**: Выбор базы данных — как выбор инструмента для ремонта. Молоток (реляционные БД) подходит для большинства задач, но для специфических работ (например, резьбы по дереву) нужны другие инструменты (графовые или time-series БД).

---

## Виды баз данных

### 1. Реляционные базы данных

- **Что это?**:
    - Основной тип баз данных, покрывающий 80–90% задач.
    - Данные хранятся в таблицах, где каждая строка представляет запись, а столбцы — атрибуты.
    - Таблицы связаны через отношения (relations) с помощью ключей (например, `user_id`).
- **Особенности**:
    - **Строгая типизация**: Поле `user_id` типа `integer` не примет строку.
    - **Связи**: Поддержка отношений "один ко многим" и "многие ко многим" через внешние ключи.
    - **Транзакционность**: Удобно для операций, где нужно изменить несколько полей одной строки атомарно.
    - Используется SQL для запросов.
- **Пример**:
    - В Яндекс.Такси реляционная база (например, PostgreSQL) хранит заказы: таблица `orders` с полями `order_id`, `user_id`, `driver_id`, `status`.
    - Таблица `users` связана с `orders` через `user_id`.
- **Когда использовать?**:
    - Когда важна транзакционность и сложные связи (например, финансовые операции, заказы).
- **Аналогия**: Реляционные БД — как аккуратный шкаф с ящиками, где всё разложено по полочкам, и вы легко находите нужное через связи.

### 2. Документо-ориентированные базы данных

- **Что это?**:
    - Основной элемент — документ (например, JSON или BSON), описывающий независимую сущность.
    - Пример базы: MongoDB.
- **Особенности**:
    - **Гибкая схема**: Структура документа может меняться (например, у одного документа есть поле `interests`, у другого — нет).
    - **Нет строгой типизации**: Можно хранить разные типы данных в одном поле.
    - **Нет SQL**: Используются специфические API для запросов.
    - Связи возможны, но неэффективны (джойны редки и дороги).
- **Пример**:
    - В Яндекс.Такси анкета пользователя (профиль): `{"user_id": "123", "name": "John", "interests": ["books", "travel"]}`.
    - Если структура профиля часто меняется, MongoDB удобнее, чем реляционная база.
- **Когда использовать?**:
    - Для независимых данных с гибкой структурой (например, анкеты, профили, резюме).
    - Не подходит для сложных связей или транзакций.
- **Аналогия**: Документо-ориентированные БД — как папка с файлами, где каждый файл (документ) самодостаточен, но связи между ними минимальны.

#### Поисковые движки

- **Что это?**:
    - Специализированные системы на базе документо-ориентированных БД (например, Elasticsearch, Sphinx).
    - Оптимизированы для полнотекстового поиска.
- **Особенности**:
    - Поддержка поиска по похожим словам (например, "ИП" → "индивидуальный предприниматель").
    - Алгоритмы: лемматизация, разбиение слов, удаление суффиксов/приставок, построение словаря.
- **Паттерн использования**:
    - **Антипаттерн**: Хранить все данные только в поисковом движке.
    - **Рекомендация**: Хранить основные данные в другой базе (например, PostgreSQL), а Elasticsearch использовать для поиска.
- **Пример**:
    - В Яндекс.Такси пользователь ищет адрес "ул. Ленина". Elasticsearch находит "Ленина", "Ленинская", "пр-т Ленина".
- **Аналогия**: Поисковые движки — как библиотечный каталог, который быстро находит книги даже по неточному запросу.

### 3. Графовые базы данных

- **Что это?**:
    - Специализированы для хранения графовых структур (вершины и рёбра).
    - Пример базы: Neo4j.
- **Особенности**:
    - Вершины — сущности (например, люди, города), рёбра — отношения ("дружит с", "живёт в").
    - Оптимизированы для поиска путей и зависимостей.
- **Пример**:
    - Соцсеть: "Я дружу с Петей", "Петя живёт в Москве", "Я родился в Ростове". Графовая база быстро найдёт связи (например, кто из друзей живёт в Москве).
    - В Яндекс.Такси: построение маршрутов между точками с учётом пробок (вершины — перекрёстки, рёбра — дороги).
- **Когда использовать?**:
    - Для задач с большим количеством связей (соцсети, маршруты, рекомендации).
    - Реляционные БД могут эмулировать графы (например, через внешние ключи), но графовые базы быстрее для таких задач.
- **Аналогия**: Графовые БД — как карта метро, где станции (вершины) связаны линиями (рёбрами), и вы быстро находите кратчайший путь.

### 4. Key-Value базы данных

- **Что это?**:
    - Простейший тип: данные хранятся как пары "ключ-значение".
    - Пример баз: Redis, Memcached, Tarantool, etcd.
- **Особенности**:
    - Аналог хеш-таблиц или словарей в программировании.
    - Часто используются как кэш, вынося данные из оперативной памяти процесса.
    - Подходят для хранения мета-информации, конфигураций, параметров кластера.
- **Пример**:
    - В YouTube: ключ — `video_id:123`, значение — `views:1500`.
    - В Яндекс.Такси: ключ — `driver_id:456`, значение — `status:available`.
    - etcd используется для сервис-дискавери (поиск сервисов в кластере) и хранения конфигураций.
- **Когда использовать?**:
    - Для кэширования (например, Redis для хранения популярных данных).
    - Для инфраструктурных задач (etcd для управления кластером).
- **Аналогия**: Key-value БД — как записная книжка, где каждому имени (ключу) соответствует номер телефона (значение).

#### Удаление кэша с префиксом в Redis

- **Вопрос**: Как удалить ключи с определённым префиксом?
- **Ответ**:
    - Использовать команду `SCAN` для поиска ключей с префиксом (например, `SCAN 0 MATCH "prefix:*"`).
    - После получения списка ключей выполнить `DEL` для их удаления.
    - **Почему `SCAN`?**: В отличие от `KEYS`, `SCAN` не блокирует сервер и подходит для больших наборов данных.
- **Пример**:
    - В Redis ключи `user:123:session`, `user:456:session`. Команда `SCAN 0 MATCH "user:*"` находит их, затем `DEL` удаляет.
- **Примечание**: Подробности инвалидации кэша и паттернов очистки будут рассмотрены позже.

### 5. Колонночные базы данных

- **Что это?**:
    - Данные хранятся по колонкам, а не по строкам (в отличие от реляционных БД).
    - Пример базы: ClickHouse.
- **Особенности**:
    - **Сжатие данных**: Колонки сжимаются эффективно (например, в ClickHouse).
    - **Оптимизация чтения**: Можно читать только нужные колонки (например, только `address` и `age`), не затрагивая остальные.
    - Не предназначены для транзакций, но идеальны для аналитики.
- **Пример**:
    - В аналитической системе ClickHouse хранит данные о поездках: колонки `user_id`, `ride_cost`, `ride_date`. Запрос "средняя стоимость поездок за месяц" читает только `ride_cost` и `ride_date`.
- **Когда использовать?**:
    - Для аналитических задач с большим объёмом чтения/записи (например, отчёты, статистика).
- **Аналогия**: Колонночные БД — как библиотека, где книги (данные) разложены по темам (колонкам), и вы берёте только нужную полку.

### 6. Time-Series базы данных

- **Что это?**:
    - Специализированы для хранения временных рядов (данных, привязанных ко времени).
    - Пример баз: Prometheus, Graphite, VictoriaMetrics.
- **Особенности**:
    - Оптимизированы для хранения метрик (например, температура, RPS, latency).
    - Реляционные БД тоже могут хранить временные ряды (с индексами), но time-series базы эффективнее.
- **Пример**:
    - В Яндекс.Такси Prometheus хранит метрики `ride_requests_per_second` с временными метками.
- **Когда использовать?**:
    - Для мониторинга и анализа временных данных (метрики, сенсоры).
- **Аналогия**: Time-series БД — как дневник погоды, где записи (данные) упорядочены по датам.

### 7. Блоковые (Object/Blob Storage) базы данных

- **Что это?**:
    - Хранят "сырые" данные (файлы, картинки, исходный код) в виде блоков (blob'ов).
    - Пример: Amazon S3, MinIO.
- **Особенности**:
    - Не предназначены для частых изменений (записал → хранишь → читаешь или удаляешь).
    - Идеальны для хранения больших неизменяемых данных.
- **Пример**:
    - В Яндекс.Такси S3 хранит фотографии профилей водителей или копии документов.
- **Когда использовать?**:
    - Для хранения файлов, резервных копий, медиа-контента.
- **Аналогия**: Blob storage — как склад, где хранятся коробки (файлы), которые редко открывают.

---

## Критерии выбора базы данных

### 1. Транзакции

- Если нужны транзакции (например, перевод денег), выбирайте реляционные БД (PostgreSQL, MySQL).
- **Пример**: В банковской системе реляционная база обеспечивает атомарность операций.

### 2. Формат представления данных

- Key-value: для парного хранения (например, кэш просмотров видео).
- Time-series: для временных метрик (например, мониторинг).
- Графовые: для связей (например, соцсети).
- **Пример**: Для аналитики поездок в Яндекс.Такси — колонночные БД (ClickHouse).

### 3. Навык работы с технологией

- Выбирайте базу, с которой у команды есть опыт, чтобы ускорить внедрение.
- **Пример**: Если команда знает PostgreSQL, начните с него, даже если MongoDB теоретически подходит.

### 4. Характер обращений к данным

- Аналитика (много чтения/записи): колонночные БД.
- Точечные операции (поиск, обновление): реляционные БД.
- **Пример**: Для отчётов по поездкам — ClickHouse, для заказов — PostgreSQL.

### 5. Сообщество и зрелость технологии

- Предпочтение проверенным решениям с активной поддержкой (например, PostgreSQL, Redis).
- **Пример**: Использование Redis вместо менее известного key-value хранилища.

### 6. Частота изменения формата данных

- Если схема часто меняется, лучше избегать строгой типизации (например, MongoDB вместо PostgreSQL).
- **Пример**: Профили пользователей с динамической структурой — MongoDB.

---

## Примеры применения

|Кейс|Тип базы данных|Причина выбора|
|---|---|---|
|Денежные средства|Реляционная (PostgreSQL)|Транзакционность, надёжность.|
|Количество просмотров видео|Key-Value (Redis)|Простое парное хранение, высокая скорость.|
|Анкета пользователя|Документо-ориентированная (MongoDB)|Гибкая структура, независимость данных.|
|Отношения между пользователями|Графовая (Neo4j)|Эффективная работа со связями.|
|Исходный код программы|Blob Storage (S3)|Хранение неизменяемых файлов.|
|Показания датчиков|Time-Series (Prometheus)|Оптимизация для временных метрик.|

### Комбинированные кейсы

- **Социальная сеть**:
    - Посты: реляционная база (PostgreSQL).
    - Аналитика (просмотры, лайки): колонночная (ClickHouse).
    - Полнотекстовый поиск: Elasticsearch.
    - Кэширование популярных постов: Redis.
- **Рекомендация**: Для небольших проектов начинайте с одной базы (например, PostgreSQL), чтобы избежать лишней сложности.

**Аналогия**: Комбинирование баз — как выбор разных ящиков для хранения: книги — на полке (реляционная), фото — в альбоме (blob), заметки — в блокноте (документо-ориентированная).

---

## Дополнительные вопросы

### Почему анкеты пользователей чаще хранят в документо-ориентированных БД?

- Анкеты независимы, имеют сложную вложенную структуру (например, интересы, карьера).
- Если нужны сложные связи или запросы — можно использовать реляционную БД.
- Для простых структур документо-ориентированные удобнее.
- **Пример**: Профиль `{"user_id": "123", "interests": ["books", "travel"], "career": {"title": "developer"}}` проще хранить в MongoDB.

### In-memory (enum) vs отдельная таблица для статусов?

- **Enum**:
    - Быстрее, так как не требует джойнов.
    - Подходит, если статусы фиксированы (например, `status: "active"/"inactive"`).
- **Отдельная таблица**:
    - Лучше для динамических статусов (возможность добавления новых).
    - Упрощает денормализацию и масштабирование.
- **Пример**:
    - В Яндекс.Такси для статуса заказа (`confirmed`, `in_progress`, `completed`) лучше таблица, если статусы могут меняться.

---

## Заключение

Мы рассмотрели основные виды баз данных, их особенности и критерии выбора. Реляционные базы универсальны, но для специфических задач (графы, аналитика, кэширование) лучше подходят специализированные решения. Важно учитывать характер данных, требования к транзакциям и опыт команды.

Выбор базы данных — как выбор транспорта: для ежедневных поездок — машина (реляционная БД), для дальних путешествий — самолёт (графовая), для хранения грузов — склад (blob storage).




# Классы баз данных

## Введение

Сегодня мы рассмотрим классы баз данных, их разделение по видам нагрузки и архитектурные особенности. Основные темы включают:

- Типы нагрузок: OLTP, OLAP, HTAP.
- Персистентные и InMemory базы данных.
- Embedded и single file базы данных.
- Механизмы повышения надёжности (снапшоты, WAL, репликация).

Масштабирование и распределённые системы будут обсуждаться на следующем занятии.

**Аналогия**: Классы баз данных — как типы транспортных средств: легковые машины (OLTP) для быстрых поездок, грузовики (OLAP) для перевозки больших грузов, и гибриды (HTAP) для универсальности.

---

## Разделение по видам нагрузки

### 1. OLTP (Online Transactional Processing)

- **Описание**: Обработка транзакций в реальном времени с высокой параллельностью.
- **Характеристики**:
    - Много коротких запросов (например, найти пользователя, обновить статус).
    - Высокая скорость и низкая задержка.
    - Примеры: создание заказа, изменение статуса заказа.
- **Пример**:
    - В Яндекс.Такси OLTP используется для обработки запросов `/orders` (поиск водителя, обновление статуса).
- **Когда использовать?**:
    - Для приложений с частыми операциями чтения/записи (CRM, онлайн-магазины).
- **Ограничения**:
    - Аналитические запросы (OLAP) могут снизить производительность при росте объёмов данных.
- **Аналогия**: OLTP — как касса в супермаркете, где быстро обрабатываются десятки транзакций одновременно.

### 2. OLAP (Online Analytical Processing)

- **Описание**: Аналитическая обработка больших объёмов данных.
- **Характеристики**:
    - Сложные запросы (например, выручка за год, анализ логов).
    - Работа с большими наборами данных.
    - Примеры: отчёты, дашборды аналитиков.
- **Пример**:
    - В Яндекс.Такси OLAP используется для анализа статистики поездок (например, средняя стоимость за месяц).
- **Когда использовать?**:
    - Для бизнес-аналитики, отчётности, исследований.
- **Ограничения**:
    - Нагрузка OLAP на OLTP-систему приводит к падению производительности.
- **Аналогия**: OLAP — как складской анализ, где изучаются данные за год, а не обрабатываются текущие продажи.

### 3. HTAP (Hybrid Transactional Analytical Processing)

- **Описание**: Гибридные базы, поддерживающие одновременно OLTP и OLAP.
- **Характеристики**:
    - Комбинируют построчное (для транзакций) и колончное (для аналитики) хранение.
    - Появились с 2014 года, активно развиваются.
- **Пример**:
    - YDB (Яндекс) поддерживает HTAP: построчное хранение для заказов и колончное для аналитики поездок.
- **Когда использовать?**:
    - Когда нужны транзакции и аналитика в одной системе (например, реальное время + отчёты).
- **Аналогия**: HTAP — как гибридный автомобиль, который ездит быстро (OLTP) и эффективно перевозит грузы (OLAP).

---

## Типы баз данных по архитектуре

### 1. Персистентные базы данных

- **Описание**: Данные хранятся на диске (HDD/SSD).
- **Характеристики**:
    - Используется движок базы для хранения данных, включая журнал (WAL — Write-Ahead Log).
    - Запросы и изменения записываются на диск для долговременного сохранения.
- **Пример**:
    - PostgreSQL сохраняет таблицы и индексы на SSD, обеспечивая надёжность.
- **Когда использовать?**:
    - Для данных, требующих долговременного хранения (например, заказы в Яндекс.Такси).
- **Аналогия**: Персистентные БД — как сейф, где документы (данные) хранятся надёжно и доступны после перезагрузки.

### 2. InMemory базы данных

- **Описание**: Данные хранятся в оперативной памяти (RAM).
- **Характеристики**:
    - Высокая скорость и низкие задержки благодаря работе в памяти.
    - Может использовать WAL или снапшоты для частичной надёжности.
    - Потеря данных при рестарте процесса.
- **Пример**:
    - Redis используется как кэш для хранения сессий пользователей в Яндекс.Такси.
- **Когда использовать?**:
    - Для временных данных или кэширования (например, популярные запросы).
- **Аналогия**: InMemory БД — как рабочий стол, где всё быстро доступно, но теряется при выключении компьютера.

#### Механизмы повышения надёжности

- **Снапшоты**:
    - Периодическое сохранение состояния на диск (например, раз в час).
    - Минус: потеря данных между последним снапшотом и сбоем.
- **WAL (Write-Ahead Log)**:
    - Запись изменений (insert, update, delete) в журнал перед подтверждением клиенту.
    - После рестарта WAL восстанавливает состояние.
- **Репликация**:
    - Синхронизация данных между инстансами (рассмотрим позже).
- **Пример комбинированного подхода**:
    - В Redis: снапшот раз в час, WAL пишет изменения, репликация дублирует данные на другой сервер.
- **Аналогия**: Это как резервное копирование: снапшот — фото, WAL — журнал изменений, репликация — зеркало.

### 3. Embedded базы данных

- **Описание**: База встраивается в приложение как библиотека.
- **Характеристики**:
    - Данные записываются в файлы на том же сервере.
    - Поддержка индексов, транзакций, конкурентного доступа без сетевых запросов.
- **Пример**:
    - В мобильном приложении Яндекс.Такси embedded база (например, SQLite) хранит локальные данные (история поездок).
- **Когда использовать?**:
    - Для локального хранения в приложениях с ограниченным доступом к сети.
- **Аналогия**: Embedded БД — как встроенный блокнот в приложении, всегда под рукой.

### 4. Single File базы данных

- **Описание**: Все данные хранятся в одном файле (включая индексы и структуру).
- **Характеристики**:
    - Пример: SQLite.
    - Легко копируется и передаётся.
    - Подходит для мобильных или небольших приложений.
- **Пример**:
    - В мобильной игре SQLite хранит прогресс игрока в одном файле.
- **Когда использовать?**:
    - Для локальных приложений с небольшим объёмом данных.
- **Аналогия**: Single file БД — как записная книжка в кармане, компактная и самодостаточная.

#### Отличие от Embedded

- Embedded база может использовать несколько файлов или каталогов (например, колоночные базы).
- Single file — строго один файл (например, SQLite).
- **Пример**: ClickHouse (embedded) хранит колонки в разных файлах, SQLite (single file) — всё в одном.

#### Вопрос по снапшотам и WAL

- **Проблема**: Снапшот раз в час теряет данные между последним сохранением и сбоем.
- **Решение**:
    - WAL записывает изменения сразу на диск, подтверждая клиенту только после этого.
    - Каждые 5–60 минут WAL компактизируется в новый снапшот.
- **Пример**:
    - В Redis WAL обеспечивает восстановление после сбоя, а снапшот сохраняет состояние раз в час.
- **Аналогия**: Снапшот — как фото дома раз в день, WAL — как видеозапись изменений, чтобы восстановить всё до минуты.

---

## Заключение

Мы разобрали классы баз данных по нагрузке (OLTP, OLAP, HTAP) и архитектуре (персистентные, InMemory, embedded, single file). OLTP подходит для транзакций, OLAP — для аналитики, а HTAP — для комбинированных задач. Персистентные базы надёжны, InMemory — быстры, но требуют механизмов вроде WAL и снапшотов. Embedded и single file базы удобны для локального использования.

**Выбор класса базы — как выбор дома: персистентные — кирпичный дом, InMemory — палатка для быстрого отдыха, embedded/single file — мини-офис в смартфоне.



# Индексы и транзакции

## Введение

- Виды индексов: B-Tree, хэш, bitmap, reverse, spatial, разряженный, покрывающий, кластерный/некластерный.
- Транзакции: ACID, уровни изоляции, аномалии, BASE.

**Аналогия**: Индексы — как указатель в книге, позволяющий быстро найти главу, а транзакции — как надёжный сейф, где данные либо полностью сохраняются, либо остаются неизменными.

---

## Индексы

### Идея индексов

Индексы — это структуры данных, ускоряющие поиск в базе. Без индексов поиск среди миллиардов записей требует **full scan** (последовательное чтение всех данных), что медленно, особенно на диске.

- **Проблема без индексов**:
    - Full scan читает все строки, что занимает O(n) времени.
- **Решение с индексами**:
    - Индексы создают дополнительную структуру, позволяющую находить данные за логарифмическое или константное время.

**Аналогия**: Индексы — как алфавитный указатель в библиотеке: вместо просмотра всех книг вы сразу находите нужную по первой букве.

### Преимущества и недостатки индексов

- **Преимущества**:
    - Ускоряют чтение (поиск, фильтрация).
- **Недостатки**:
    - Замедляют запись (вставка/обновление требует изменения индекса).
    - Занимают дополнительную память.
- **Пример**:
    - В Яндекс.Такси индекс по `order_id` ускоряет поиск заказа, но добавление нового заказа требует обновления индекса.

### Виды индексов

#### 1. B-Tree (B-дерево)

- **Описание**:
    - Основной индекс в реляционных СУБД (например, PostgreSQL, MySQL).
    - Узлы содержат множество значений (ветвистость T = 100–200), что делает дерево широким и менее глубоким.
- **Особенности**:
    - Минимизирует операции ввода-вывода (seek-time) на диске.
    - Узлы хранят диапазоны ключей и ссылки на данные (или оффсеты).
- **Алгоритм поиска**:
    1. Начинаем с корня.
    2. Определяем диапазон ключей и переходим к нужному узлу.
    3. Повторяем, пока не найдём данные.
- **Сложность**: O(t * logₜ(n)), где t — ветвистость, n — количество записей.
- **Пример**:
    - В таблице `orders` индекс B-Tree по `order_id` позволяет быстро найти заказ, минимизируя обращения к диску.
- **Когда использовать?**:
    - Для большинства операций поиска, включая диапазоны (например, `WHERE date BETWEEN ...`).
- **Аналогия**: B-Tree — как карта города, где улицы (узлы) разделены на районы (диапазоны), и вы быстро находите нужный адрес.

#### 2. Хэш-индекс

- **Описание**:
    - Хэш-таблица, хранящая ключ и указатель на данные.
- **Особенности**:
    - Поиск за O(1) (point lookup).
    - Не поддерживает поиск по диапазону (например, `WHERE age > 30`).
- **Пример**:
    - В Яндекс.Такси хэш-индекс по `driver_id` ускоряет поиск водителя по точному ID.
- **Когда использовать?**:
    - Для точечных запросов (например, поиск по первичному ключу).
- **Аналогия**: Хэш-индекс — как номерной ящик в почтовом отделении: по номеру (ключу) сразу находите письмо.

#### 3. Bitmap-индекс

- **Описание**:
    - Используется для бинарных или дискретных признаков.
    - Каждый признак — бит в числовом поле.
- **Особенности**:
    - Поиск через побитовые операции (AND, OR), что очень быстро.
    - Компактен, обычно хранится в памяти.
- **Пример**:
    - В Яндекс.Такси bitmap-индекс хранит опции поездки: `can_with_pet`, `has_hookah`. Поиск машин с нужными опциями — мгновенный.
- **Когда использовать?**:
    - Для фильтрации по множеству бинарных признаков.
- **Аналогия**: Bitmap-индекс — как фильтр в интернет-магазине: выбираете "цвет: красный" и "размер: M", и система быстро находит товары.

#### 4. Reverse (обратный) индекс

- **Описание**:
    - Используется для полнотекстового поиска (например, в Elasticsearch).
    - По каждому слову хранится список документов, где оно встречается.
- **Особенности**:
    - Поддерживает сложные запросы через merge/intersect операций.
- **Пример**:
    - В поисковой системе по слову "такси" обратный индекс возвращает список документов, где это слово есть.
- **Когда использовать?**:
    - Для полнотекстового поиска (например, поиск по адресам в Яндекс.Такси).
- **Аналогия**: Reverse индекс — как словарь, где для каждого слова указаны страницы книги, где оно встречается.

#### 5. Spatial (пространственный) индекс

- **Описание**:
    - Для многомерных данных (например, координаты).
    - Пример: quad-дерево делит пространство на квадраты.
- **Особенности**:
    - Рекурсивное деление пространства.
    - Ограничения по глубине дерева и объёму данных в квадрате.
- **Пример**:
    - В Яндекс.Такси spatial индекс по координатам (`latitude`, `longitude`) помогает найти ближайших водителей.
- **Когда использовать?**:
    - Для геолокационных запросов (например, поиск объектов в радиусе).
- **Аналогия**: Spatial индекс — как карта с сеткой, где каждый квадрат помогает быстро найти ближайшую точку.

#### 6. Разряженный индекс

- **Описание**:
    - Индексируется не каждая запись, а группы (например, каждая 1000-я).
- **Особенности**:
    - Уменьшает объём индекса и ускоряет вставки.
    - Используется при чтении большими блоками.
- **Пример**:
    - В ClickHouse разряженный индекс хранит указатели на каждую 1000-ю запись, ускоряя аналитические запросы.
- **Когда использовать?**:
    - Для аналитических баз (например, ClickHouse), где данные читаются пачками.
- **Аналогия**: Разряженный индекс — как оглавление книги, указывающее только на главы, а не на каждую страницу.

#### 7. Покрывающий индекс

- **Описание**:
    - В индекс включаются не только ключи, но и данные, которые нужно вернуть.
- **Особенности**:
    - Запрос полностью выполняется через индекс, без обращения к таблице (heap-файлу).
- **Пример**:
    - В таблице `users` покрывающий индекс по `user_id` включает `name`. Запрос `SELECT name FROM users WHERE user_id = 123` не трогает основную таблицу.
- **Когда использовать?**:
    - Для запросов, где возвращаются ограниченные поля.
- **Аналогия**: Покрывающий индекс — как краткая выписка, где всё нужное уже собрано, и не нужно лезть в архив.

#### 8. Кластерный и некластерный индексы

- **Кластерный индекс**:
    - Строки таблицы физически упорядочены по ключу (например, primary key).
    - Таблица сортируется при вставке.
- **Некластерный индекс**:
    - Отдельная структура, не влияющая на порядок строк.
    - Все остальные индексы (B-Tree, хэш, bitmap, spatial) — некластерные.
- **Особенности**:
    - Хэш-индекс не может быть кластерным, так как хэш не поддерживает упорядочивание.
- **Пример**:
    - В таблице `orders` кластерный индекс по `order_id` сортирует строки, некластерный B-Tree по `status` — просто указатель.
- **Когда использовать?**:
    - Кластерный: для основного ключа (например, primary key).
    - Некластерный: для дополнительных фильтров.
- **Аналогия**: Кластерный индекс — как книги на полке, отсортированные по алфавиту, некластерный — как указатель, не меняющий порядок.

---

## Транзакции

### Что такое транзакция?

Транзакция — это набор операций, выполняемых как единое целое: либо всё проходит успешно, либо всё откатывается (принцип "всё или ничего").

**Аналогия**: Транзакция — как прыжок через обрыв: нельзя перепрыгнуть на 90%, вы либо полностью на другой стороне, либо падаете.

### ACID: Гарантии транзакций

ACID — стандарт, описывающий требования к транзакциям, но не их реализацию.

#### A — Atomicity (Атомарность)

- Транзакция выполняется полностью или не выполняется вовсе.
- Если одна операция не прошла, всё откатывается (rollback).
- **Пример**:
    - Перевод 500 рублей от user 111 (баланс 1500) к user 222 (баланс 1500):
        
        1. Списываем 500 у user 111 → баланс 1000.
        2. Добавляем 500 к user 222 → баланс 2000.
        
        - Если второй шаг не прошёл, откатываем первый: оба остаются с 1500.
- **Аналогия**: Атомарность — как упаковка посылки: либо всё собрано и отправлено, либо ничего не ушло.

#### C — Consistency (Согласованность)

- Транзакция переводит базу из одного согласованного состояния в другое.
- Ограничения (constraints) вроде `not null`, `unique`, `foreign key` не нарушаются.
- Бизнес-логика (например, запрет отрицательного баланса) должна дублироваться в БД.
- **Пример**:
    - Попытка записать неуникальный `user_id` в таблицу с `unique` constraint откатит транзакцию.
- **Аналогия**: Согласованность — как правила дорожного движения: нельзя ехать на красный, иначе авария.

#### I — Isolation (Изоляция)

- Транзакции выполняются изолированно, создавая иллюзию, что других транзакций нет.
- **Аномалии при параллельности**:
    1. **Потерянное обновление (lost update)**:
        - Две транзакции увеличивают просмотры видео (100 → 101). Обе читают 100, пишут 101 — теряется одно обновление.
    2. **Грязное чтение (dirty read)**:
        - Транзакция 1 меняет баланс, но не фиксирует. Транзакция 2 читает изменённый баланс. Если 1 откатится, 2 получит неверные данные.
    3. **Неповторяющееся чтение (non-repeatable read)**:
        - В одной транзакции два `SELECT` возвращают разные данные из-за изменений другой транзакцией.
    4. **Чтение фантомов (phantom read)**:
        - Появление новых строк (INSERT) меняет результат `SELECT` в одной транзакции.
- **Уровни изоляции** (зависят от СУБД):
    - **Read Uncommitted**: Возможны все аномалии.
    - **Read Committed**: Нет грязных чтений.
    - **Repeatable Read**: Нет грязных и неповторяющихся чтений.
    - **Serializable**: Полная изоляция, но низкая производительность.
- **Реализация**:
    - **Локи**:
        - 2PL (Two-Phase Locking): фаза 1 — берём локи, фаза 2 — снимаем.
        - Проблема: дедлоки (решение — брать локи в одном порядке).
    - **MVCC (Multi-Version Concurrency Control)**:
        - Каждая запись имеет метаданные (например, `xmin/xmax` в PostgreSQL).
        - `SELECT` читает валидные версии, `UPDATE` создаёт новую версию (insert + delete).
        - Уборка старых версий: VACUUM в PostgreSQL.
- **Пример**:
    - В Яндекс.Такси две транзакции обновляют статус заказа. MVCC обеспечивает, что каждая видит свою версию данных.
- **Аналогия**: Изоляция — как отдельные кабинки для голосования: никто не мешает друг другу.

#### D — Durability (Надёжность)

- После `commit` данные гарантированно сохранены, даже при сбое.
- **Механизм**:
    - Используется WAL (Write-Ahead Log):
        1. Запись в WAL.
        2. Подтверждение клиенту.
        3. Асинхронное обновление основного хранилища.
- **Пример**:
    - PostgreSQL пишет изменения в WAL, гарантируя, что после сбоя данные восстановятся.
- **Аналогия**: Надёжность — как сейф: после закрытия замка содержимое не потеряется.

#### Deferrable Transactions

- **Описание**:
    - Проверка constraints откладывается до конца транзакции.
- **Пример**:
    - Таблицы `husbands` и `wives` ссылаются друг на друга (`foreign key`). Deferrable транзакция позволяет вставить записи, проверяя ограничения в конце.
- **Синтаксис** (зависит от СУБД):
    - Например, в PostgreSQL: `START TRANSACTION LEVEL DEFERRABLE`.
- **Аналогия**: Это как откладывание проверки билетов на концерт до конца мероприятия.

### BASE: Альтернатива ACID

BASE — концепция для масштабируемых NoSQL-баз (например, Cassandra).

- **B — Basically Available**:
    - Доступность через репликацию в кластере.
- **S — Soft State**:
    - Временная несогласованность данных (нет строгих constraints).
- **E — Eventual Consistency**:
    - Данные сходятся к согласованному состоянию со временем.
- **Пример**:
    - В Cassandra данные реплицируются с задержкой, но в итоге все ноды синхронизируются.
- **Аналогия**: BASE — как слухи в деревне: информация доходит до всех, но не сразу.

#### ACID vs BASE

- **ACID**: Строгая согласованность, подходит для реляционных БД (PostgreSQL).
- **BASE**: Высокая доступность, подходит для NoSQL (Cassandra).
- **Современность**:
    - Граница размывается: NoSQL-базы (например, Tarantool) начинают поддерживать транзакции.
- **Пример**:
    - В Яндекс.Такси для заказов (ACID) используется PostgreSQL, для аналитики (BASE) — Cassandra.

---

## Заключение

Индексы ускоряют поиск в базах данных, но увеличивают затраты на запись и память. B-Tree универсален, хэш подходит для точечных запросов, bitmap — для бинарных фильтров, а spatial — для геоданных. Транзакции (ACID) обеспечивают надёжность и согласованность, тогда как BASE фокусируется на доступности и масштабируемости. Выбор подхода зависит от требований проекта.

Индексы — как навигатор, ускоряющий путь, а транзакции (ACID/BASE) — как правила движения, определяющие, что важнее: безопасность или скорость.



# Объекты баз данных и стратегии удаления данных

## Введение

Мы продолжаем изучение баз данных, фокусируясь на объектах, которые позволяют автоматизировать операции и реализовать бизнес-логику на уровне СУБД. Также разберём задачу периодического удаления данных с разными подходами к реализации. Основные темы:

- Объекты баз данных: хранимые процедуры, триггеры, материализованные представления, watch/notify.
- Задача: удаление устаревших данных (хранение данных за последний час).

**Аналогия**: Объекты баз данных — как инструменты в мастерской: каждый решает свою задачу, а правильный выбор инструмента упрощает работу.

---

## Объекты в базах данных

Объекты баз данных позволяют исполнять логику, автоматизировать операции и реагировать на события непосредственно внутри СУБД. Это "кубики", из которых строятся архитектурные паттерны.

### 1. Код на уровне базы данных (хранимые процедуры)

- **Описание**:
    - Код (например, на PL/pgSQL в PostgreSQL) пишется и исполняется внутри СУБД.
- **Преимущества**:
    - Быстрее, так как выполняется внутри базы, без сетевых задержек.
    - Исторически популярно в некоторых командах.
- **Недостатки**:
    - Сложно найти специалистов для поддержки.
    - Трудности с тестированием и версионированием (нет нормального version control).
    - Часто требуется использовать "костыли".
- **Пример**:
    - В Яндекс.Такси хранимая процедура может автоматически рассчитывать стоимость поездки на основе данных в таблице `rides`.
- **Когда использовать?**:
    - Если архитектура требует логики на уровне базы (например, для сложных расчётов).
- **Рекомендация**:
    - Лектор предпочитает избегать хранимых процедур, перенося логику в приложение.
- **Аналогия**: Хранимые процедуры — как встроенный калькулятор в кассовом аппарате: удобно, но не всегда гибко.

### 2. Триггеры

- **Описание**:
    - Автоматическое выполнение действий при изменениях в таблице (вставка, обновление, удаление).
- **Типы событий**:
    - `AFTER INSERT`: После добавления записи.
    - `AFTER UPDATE`: После обновления записи.
    - `AFTER DELETE`: После удаления записи.
- **Пример**:
    - В Яндекс.Такси триггер на `INSERT` в таблицу `orders` автоматически добавляет запись в таблицу `statistics` для подсчёта заказов.
- **Когда использовать?**:
    - Для автоматизации задач (например, логирование изменений, обновление связанных данных).
- **Аналогия**: Триггеры — как датчик движения, который включает свет, когда вы входите в комнату.

### 3. Материализованные представления (Materialized Views)

- **Описание**:
    - Кэширование результатов сложных запросов (например, с `JOIN` и агрегатами).
    - Данные хранятся физически и обновляются по заданному сценарию.
- **Обновление**:
    - По расписанию (например, раз в час).
    - По событию (например, после изменения таблицы).
    - Вручную (зависит от СУБД).
    - Пример: `REFRESH MATERIALIZED VIEW` в PostgreSQL.
- **Пример**:
    - В Яндекс.Такси материализованное представление хранит среднюю стоимость поездок за день, рассчитанную из `rides` с `JOIN` на `users`.
- **Когда использовать?**:
    - Для оптимизации тяжёлых запросов, которые часто выполняются.
- **Аналогия**: Материализованное представление — как распечатанный отчёт: данные уже готовы, но их нужно обновлять.

### 4. Watch/Notify и очереди изменений

- **Описание**:
    - Механизм отслеживания изменений (например, в etcd через `watch`).
    - При изменении данных (например, ключа) генерируется событие (ивент).
- **Применение**:
    - Репликация.
    - Избрание лидера в кластере.
    - Реакция на изменения (например, смена IP-адреса сервера).
- **Пример**:
    - В распределённой системе etcd уведомляет сервисы об изменении конфигурации (например, новый лидер кластера).
- **Когда использовать?**:
    - Для реактивных систем и распределённых сценариев.
- **Аналогия**: Watch/Notify — как подписка на новости: вы сразу узнаёте об обновлениях.

---

## Задача: Периодическое удаление данных

**Требования**:

- Хранить данные только за последний час.
- Раз в час удалять устаревшие записи.

### Возможные способы реализации

#### 1. Крон

- **Описание**:
    - Внешний процесс (например, скрипт на Python) запускается через `cron` раз в час.
    - Скрипт сканирует таблицу и удаляет записи старше часа (`WHERE timestamp < NOW() - INTERVAL '1 hour'`).
- **Плюсы**:
    - Простота реализации.
- **Минусы**:
    - Full scan таблицы может быть медленным для больших данных.
    - Нагрузка на базу при каждом запуске.
- **Пример**:
    - В PostgreSQL скрипт выполняет: `DELETE FROM events WHERE timestamp < NOW() - INTERVAL '1 hour';`.
- **Аналогия**: Крон — как уборщик, который раз в час проверяет весь склад и выбрасывает старое.

#### 2. Встроенный в базу данных scheduler

- **Описание**:
    - Использование встроенного планировщика СУБД (например, Event Scheduler в MySQL).
    - Процедура удаления запускается автоматически раз в час.
- **Плюсы**:
    - Не требует внешнего процесса.
    - Управляется на уровне базы.
- **Минусы**:
    - Всё ещё может быть full scan.
    - Не все СУБД поддерживают (например, SQLite).
- **Пример**:
    - В MySQL: `CREATE EVENT clean_old_data ON SCHEDULE EVERY 1 HOUR DO DELETE FROM events WHERE timestamp < NOW() - INTERVAL 1 HOUR;`.
- **Аналогия**: Scheduler — как автоматический пылесос, работающий по расписанию внутри дома.

#### 3. Использование TTL (Time-to-Live)

- **Описание**:
    - Некоторые СУБД (например, MongoDB, ClickHouse, Cassandra) поддерживают TTL на уровне таблицы.
    - Записи автоматически удаляются по истечении времени.
- **Плюсы**:
    - Полностью автоматический процесс.
    - Не требует full scan.
- **Минусы**:
    - Поддерживается не всеми базами (например, PostgreSQL не имеет встроенного TTL).
- **Пример**:
    - В MongoDB: `db.events.createIndex({"timestamp": 1}, {expireAfterSeconds: 3600})` — записи удаляются через час.
- **Аналогия**: TTL — как продукты с истекающим сроком годности: они автоматически "исчезают" из холодильника.

#### 4. Партиционирование

- **Описание**:
    - Таблица делится на партиции по часам (например, каждая партиция — данные за 1 час).
    - Раз в час удаляется (дропается) устаревшая партиция.
- **Плюсы**:
    - Удаление партиции — быстрая операция (O(1), не требует full scan).
    - Упрощает управление большими данными.
- **Минусы**:
    - Требует настройки партиций.
    - Не все запросы оптимизированы для партиций.
- **Пример**:
    - В PostgreSQL таблица `events` партиционируется по `timestamp`. Команда `DROP TABLE events_2025_05_30_12` удаляет данные за 12:00.
- **Аналогия**: Партиционирование — как ящики с метками по датам: старый ящик просто выбрасывается целиком.

---

## Заключение

Объекты баз данных (хранимые процедуры, триггеры, материализованные представления, watch/notify) позволяют автоматизировать задачи и реализовать логику на уровне СУБД. Они становятся "кубиками" для построения сложных архитектурных паттернов. Для периодического удаления данных подходы вроде TTL и партиционирования предпочтительнее, так как минимизируют нагрузку на базу по сравнению с крон или scheduler. Выбор метода зависит от возможностей СУБД и требований проекта.

**Аналогия**: Объекты БД и стратегии удаления — как автоматизация на заводе: правильный выбор механизмов (конвейер, робот, таймер) ускоряет работу и снижает затраты.




# Брокеры сообщений и альтернативные способы хранения данных

## Введение

Мы продолжаем изучение баз данных, переходя к брокерам сообщений и альтернативным подходам к хранению данных. Основные темы:

- Брокеры сообщений: концепции, примеры, архитектура (Kafka, RabbitMQ).
- Буферизация данных, асинхронная связь, отказоустойчивость, масштабируемость.
- Альтернативные способы хранения: клиентское хранение, CDN.
- Задание к занятию.

Подробное обсуждение брокеров, паттернов и агрегирования отложено на следующие занятия.

**Аналогия**: Брокеры сообщений — как почтовая служба, доставляющая письма между отделами, а альтернативное хранение — как выбор между бумажным архивом и облачным сервисом.

---

## Брокеры сообщений

Брокеры сообщений обеспечивают асинхронную коммуникацию между сервисами, уменьшая связанность и перераспределяя нагрузку. Подробности будут на третьем и четвёртом занятиях.

### Концепции и преимущества

- **Что это?**:
    - Средство для передачи сообщений между сервисами через очереди.
- **Преимущества**:
    - Уменьшение связанности: сервисы не зависят друг от друга.
    - Перераспределение нагрузки: задачи обрабатываются асинхронно.
    - Репликация партиций и масштабирование компонентов.
- **Примеры**:
    - Очереди для асинхронной обработки заказов в Яндекс.Такси.
    - Репликация данных между серверами.
- **Аналогия**: Брокер — как конвейер, который передаёт детали между цехами без их прямого взаимодействия.

### Буферизация данных через очередь

- **Описание**:
    - Обработка данных пачками (например, 20–30 записей) вместо одной.
    - Данные помещаются в очередь и обрабатываются позже.
- **Пример**:
    - В Яндекс.Такси очередь буферизирует события поездок для аналитики.
- **Аналогия**: Буферизация — как корзина для покупок: собираете товары и оплачиваете всё разом.

### Асинхронная связь

- **Описание**:
    - Сервис отправляет задачу в очередь и продолжает работу, не дожидаясь ответа.
- **Пример**:
    - Пользователь отправляет заказ в Яндекс.Такси, а обработка (поиск водителя) происходит в фоне.
- **Аналогия**: Асинхронность — как запуск стиральной машины: вы занимаетесь своими делами, пока она работает.

### Слабое связывание

- **Описание**:
    - Сервисы (левый и правый) не знают друг о друге, общаются через очередь.
- **Преимущество**:
    - Независимое масштабирование и настройка.
- **Пример**:
    - В Яндекс.Такси сервис заказов и сервис оплаты работают через очередь, их можно масштабировать отдельно.
- **Аналогия**: Слабое связывание — как почтовый ящик: отправитель не знает, кто и когда заберёт письмо.

### Масштабируемость

- **Описание**:
    - Компоненты системы масштабируются независимо.
- **Пример**:
    - Увеличение числа консюмеров для обработки заказов в Яндекс.Такси без изменения продюсеров.
- **Аналогия**: Масштабируемость — как добавление новых рабочих линий на заводе без остановки производства.

### Отказоустойчивость

- **Описание**:
    - Сообщения сохраняются в очереди даже при сбое сервиса.
- **Пример**:
    - Если сервис оплаты в Яндекс.Такси упал, очередь сохранит заказ, и обработка возобновится после восстановления.
- **Конфигурация**:
    - Степень отказоустойчивости зависит от размера буфера и места хранения.
- **Аналогия**: Отказоустойчивость — как почтовый ящик с замком: письма не пропадут, даже если почтальон заболел.

### Поток данных и модели

- **Шина данных**:
    - Включает продюсеров (отправителей), консюмеров (получателей) и брокера.
    - Подробности — на следующих занятиях.
- **Модели**:
    - **Push**: Сервис активно отправляет данные (быстро, но требует настройки периодичности).
    - **Pull**: Сервис запрашивает данные по расписанию (устойчив к DDoS, контролирует частоту).
- **Пример**:
    - Push: Отправка уведомлений в реальном времени.
    - Pull: Аналитика периодически запрашивает данные из очереди.
- **Аналогия**: Push — как посылка с курьером, Pull — как заказ с самовывозом.

---

## Kafka: Основные компоненты и особенности

- **Продюсер**:
    - Пишет данные в очередь (топик).
- **Консюмер**:
    - Читает данные по pull-модели.
- **Брокер**:
    - Сервер Kafka в кластере.
- **Топик**:
    - Логическая очередь, аналог таблицы в БД.
- **Партиция**:
    - Физическая часть топика (хотя бы одна партиция обязательна).
- **Offset**:
    - Смещение в партиции, показывающее прочитанные записи.
- **Data Retention**:
    - Данные не удаляются после чтения, а помечаются как прочитанные.
    - Удаление конфигурируется (например, через час, день, год).
- **Пример**:
    - В Яндекс.Такси топик `ride_events` с партициями хранит события поездок, консюмер читает с offset 100.
- **Аналогия**: Kafka — как лента конвейера: каждый участок (партиция) обрабатывается отдельно, а данные остаются доступными.

### Роутинг и партиционирование

- **Описание**:
    - Данные распределяются по партициям через роутинг (хэш, фиксированные правила, random).
- **Конфигурация**:
    - Задаётся в коде или через SDK.
- **Пример**:
    - В Яндекс.Такси роутинг по `ride_id` распределяет записи по партициям.
- **Аналогия**: Роутинг — как распределение писем по ящикам в почтовом отделении.

---

## RabbitMQ: Модель и архитектура

- **Exchange**:
    - Биржа для роутинга (Direct, Key-based, Fanout и др.).
    - Не хранит данные.
- **Queue**:
    - Очередь, где хранятся сообщения.
- **Модель**:
    - Push-модель: данные удаляются после подтверждения консюмером.
- **Пример**:
    - В Яндекс.Такси Exchange направляет сообщения об отмене заказа в очередь для уведомлений.
- **Аналогия**: RabbitMQ — как почтовый сортировочный центр: Exchange распределяет, Queue доставляет.

---

## Data Retention

- **Описание**:
    - Хранение данных в течение заданного времени (например, 4 дня в Яндексе для трекинга).
- **Пример**:
    - В Яндекс.Такси данные поездок хранятся 7 дней по бизнес-требованиям.
- **Аналогия**: Data Retention — как архив с установленным сроком хранения документов.

---

## Гарантии доставки

- **At least once**:
    - Доставка хотя бы раз (возможны дубликаты).
- **At most once**:
    - Не более одного раза (возможна потеря).
- **Exactly once**:
    - Ровно один раз (через идемпотентность).
- **Пример**:
    - В Яндекс.Такси для оплаты используется `exactly once` с уникальными ID транзакций.
- **Аналогия**: Гарантии — как доставка письма: минимум раз, максимум раз или ровно раз.

### Retri и идемпотентность

- **Retri**:
    - Повторная отправка при сбое для достижения гарантий.
- **Идемпотентность**:
    - Предотвращение дубликатов через уникальные ключи.
- **Пример**:
    - В Kafka повторная отправка с тем же `message_id` игнорируется благодаря идемпотентности.
- **Аналогия**: Retri — как повторный звонок, идемпотентность — как отметка "прочитано".

---

## Альтернативные способы хранения данных

### На клиенте

- **Описание**:
    - Хранение данных на клиентском устройстве (например, толстый клиент).
- **Пример**:
    - В мобильном приложении Яндекс.Такси кэшируются последние поездки.
- **Аналогия**: Клиентское хранение — как записная книжка в кармане.

### CDN (Content Delivery Network)

- **Архитектура**:
    - **POP (Point of Presence)**: Кеш-серверы близко к пользователю.
    - **Прокси**: Определяет географию и перенаправляет запросы.
    - **Origin**: Исходный сервер с данными.
- **Модели**:
    - **Pull**: Данные кэшируются при запросе (экономит трафик).
    - **Push**: Данные заранее загружаются (например, Netflix перед релизом).
- **Пример**:
    - В Яндекс.Такси статические карты кэшируются через CDN для снижения latency.
- **Аналогия**: CDN — как сеть местных складов, где товары доступны ближе к покупателю.

---

## Задание к занятию

- Пересмотреть запись и дизайн WhatsApp: проанализировать архитектуру хранения данных и предложить улучшения.
- Изучить темы с вопросами (агрегирование, инвалидация) и задать их в чате.
- Провести парное моб-собеседование по проектированию API:
    - 30 минут на каждого.
    - Подготовить две темы заранее (если одна совпадёт, будет запасная).

---

## Заключение

Брокеры сообщений (Kafka, RabbitMQ) обеспечивают асинхронность, масштабируемость и отказоустойчивость через очереди и партиции. Альтернативное хранение (клиент, CDN) оптимизирует доступ к данным. Эти подходы — основа для построения сложных систем, которые будут детально разобраны на следующих занятиях.

**Аналогия**: Брокеры и CDN — как инфраструктура доставки: очереди распределяют задачи, а кэш ускоряет доступ к контенту.




