{
	"nodes":[
		{"id":"161b28a1b06f9c5e","type":"text","text":"планировщик","x":-108,"y":-52,"width":168,"height":52},
		{"id":"0cc083647a5c7007","type":"text","text":"Планировщик в Golang - это механизм, который отвечает за распределение и выполнение горутин (G) на логических процессорах (P), которые в свою очередь работают на физических потоках (M) операционной системы. Планировщик в Golang использует модель M:N, то есть может запускать произвольное количество горутин на произвольном количестве потоков.\n\nГорутина (G) - это легковесный поток выполнения, который может быть создан, переключен и уничтожен планировщиком Go без взаимодействия с операционной системой. Горутины занимают мало памяти и могут быть заспавнены в большом количестве. Горутины не привязаны к конкретному потоку или процессору, а могут динамически менять свой контекст выполнения.\n\nЛогический процессор (P) - это абстракция, которая представляет собой ресурс, необходимый для выполнения горутин. Каждый P имеет свою локальную очередь (LRQ), в которой хранятся горутины, ожидающие запуска. Количество P обычно равно количеству ядер в системе, чтобы максимально использовать параллелизм. P не может выполнять горутину самостоятельно, а нуждается в M для этого.\n\nФизический поток (M) - это поток операционной системы, который может быть связан с P и выполнять горутину из LRQ. M может переключаться между разными P в зависимости от ситуации. Например, если M блокируется на системном вызове или операции ввода-вывода, он может быть отсоединен от P и заменен другим M. Также M может участвовать в процессе work stealing, когда он пытается украсть горутину из LRQ или глобальной очереди (GRQ) другого P.","x":-304,"y":-980,"width":560,"height":760},
		{"id":"ab05a03cadfec8c5","type":"text","text":"Планировщик в Golang - это вытесняющий планировщик с кооперативными элементами. \n\nЭто означает, что он может прервать выполнение текущей горутины в любой момент и передать управление другой горутине, если он посчитает это необходимым, но он также полагается на то, что горутины будут добровольно освобождать процессор, когда они будут ждать ввода-вывода или блокироваться на каналах.\n\nПланировщик в Golang использует таймер или другие прерывания, чтобы определить, когда нужно сменить горутину, а также учитывает приоритеты и аффинность горутин к процессорам.","x":-283,"y":140,"width":518,"height":378},
		{"id":"5f35a01103c582d4","type":"text","text":"вопросы","x":-700,"y":-56,"width":250,"height":60},
		{"id":"57d82cef1223c890","type":"text","text":"В общем случае, нет, нельзя руками переключить контекст горутины, так как это делает планировщик Golang автоматически, когда он посчитает это необходимым.\n\nОднако, в некоторых редких случаях, можно руками переключить контекст горутины, используя низкоуровневые функции из пакета runtime, такие как runtime.Gopark и runtime.Goready, которые позволяют приостановить и возобновить горутину по собственному условию. Эти функции не рекомендуются для обычного использования, так как они могут привести к ошибкам и несовместимостям с планировщиком Golang.","x":-1480,"y":-880,"width":459,"height":380},
		{"id":"9e41c95e22d79a1f","type":"text","text":"Количество потоков операционной системы, которые мы можем создать в Golang, зависит от нескольких факторов, таких как:\n\n- Количество горутин (goroutines), которые мы запускаем в нашей программе.\n- Количество процессоров или ядер на компьютере. По умолчанию Golang создает столько системных потоков, сколько доступно логических процессоров на компьютере, но это можно изменить с помощью переменной окружения GOMAXPROCS.\n- Размер стека для каждого системного потока. Стек - это область памяти, которая используется для хранения локальных переменных, параметров и адресов возврата функций. Размер стека ограничивает количество системных потоков, которые могут быть созданы, так как память не бесконечна.","x":-1820,"y":-276,"width":459,"height":500},
		{"id":"a66eb1eff1e2b3e8","type":"text","text":"Глобальная и локальная очереди в Golang - это структуры данных, которые используются планировщиком Go для распределения горутин между логическими процессорами (P). Горутина - это легковесный поток выполнения, который может быть переключен планировщиком без блокировки операционной системы.\n\nГлобальная очередь выполнения (GRQ) содержит горутины, которые еще не были назначены ни одному логическому процессору. Когда логический процессор создается или освобождается, он может взять горутину из GRQ и поместить ее в свою локальную очередь выполнения (LRQ). LRQ содержит горутины, которые принадлежат конкретному логическому процессору и ожидают своего запуска.\n\nПланировщик Go использует алгоритм work stealing для балансировки нагрузки между логическими процессорами. Если LRQ одного логического процессора пуста, он может попытаться украсть горутину из LRQ другого логического процессора или из GRQ. Это позволяет эффективно использовать ресурсы и избегать простоя.","x":-1980,"y":477,"width":662,"height":483},
		{"id":"213f503a7041710d","type":"text","text":"**GMP** — это модель выполнения программ в языке Go, которая реализует лёгкие, эффективные горутины. Аббревиатура **GMP** расшифровывается как:\n\n- **G** — Goroutine (Горутина): абстракция лёгкого потока выполнения.\n- **M** — Machine (OS Thread): операционная системная нить (OS thread).\n- **P** — Processor (Logical Processor): логический процессор","x":533,"y":-744,"width":473,"height":288},
		{"id":"683cde9ce5e8ca4f","type":"text","text":"В планировщике Go параллельное выполнение достигается за счет M:N модели, где M горутин распределяются на N системных потоков. Управление выполняется рантаймом через GPM-модель (Goroutine, Process, Machine). Вытеснение обеспечивается с помощью точек прерывания в длительных задачах, начиная с Go 1.14, что позволяет планировщику эффективно переключаться между горутинами.","x":-226,"y":620,"width":404,"height":316},
		{"id":"a6c27932d4dbb864","type":"text","text":"Разница между вытесняющим (**preemptive**) и кооперативным (**cooperative**) планировщиком заключается в том, как управление передается между задачами (или потоками выполнения) в многозадачной системе:\n\n---\n\n### 1. **Вытесняющий планировщик**\n\n- **Принцип работы:** Планировщик самостоятельно решает, когда и какую задачу приостановить или продолжить. Задачи вытесняются по расписанию или в зависимости от их приоритетов.\n- **Как работает:**\n    - Планировщик периодически прерывает выполнение задачи (например, с использованием таймера или прерываний).\n    - Контекст задачи сохраняется, и управление передается другой задаче.\n- **Преимущества:**\n    - Обеспечивает более равномерное распределение процессорного времени между задачами.\n    - Не требует, чтобы задачи самостоятельно уступали управление, что особенно полезно в системах с \"плохо написанным\" кодом.\n- **Недостатки:**\n    - Вызывает накладные расходы на переключение контекста.\n    - Требует дополнительных механизмов синхронизации из-за частого прерывания задач.\n- **Пример:** Операционные системы общего назначения (Windows, Linux, macOS).\n\n---\n\n### 2. **Кооперативный планировщик**\n\n- **Принцип работы:** Управление передается от одной задачи другой только в том случае, если текущая задача явно освобождает управление.\n- **Как работает:**\n    - Каждая задача должна самостоятельно вызывать методы или функции для передачи управления (например, `yield` или завершение задачи).\n- **Преимущества:**\n    - Нет необходимости в сложных механизмах синхронизации.\n    - Накладные расходы на переключение задач минимальны.\n- **Недостатки:**\n    - Если одна задача \"захватывает\" управление (например, бесконечный цикл или долгий блокирующий код), другие задачи не могут быть выполнены.\n    - Зависят от корректного написания кода в задачах.\n- **Пример:** Некоторые встроенные системы, ранние версии Windows, JavaScript (в одном потоке).\n\n---\n\n### В контексте Golang\n\n- Планировщик Go изначально использовал **кооперативную модель**: горутины освобождали управление только в определенных точках, например, при вызове функций `runtime.Gosched()`, операций ввода/вывода или других системных вызовов.\n- Начиная с Go 1.14, добавлен **вытесняющий планировщик**, который может принудительно прерывать выполнение длинных задач. Это сделано для предотвращения ситуации, когда \"зависшая\" горутина блокирует выполнение других. Вытеснение достигается через **проверку точек прерывания** при длительном выполнении кода, особенно в длинных циклах.","x":742,"y":473,"width":658,"height":1607},
		{"id":"aa9e7d5504923883","type":"text","text":"До версии Go 1.15 планировщик переключал контекст горутин в нескольких случаях, что обеспечивало эффективное распределение времени между горутинами. Основные операции, приводившие к переключению контекста:\n\n1. **Операции ввода/вывода (I/O):**\n    \n    - Когда горутина блокировалась на операции ввода/вывода, например, при чтении или записи в файл, планировщик мог переключить контекст и выполнить другую горутину.\n2. **Системные вызовы:**\n    \n    - Прерывания в системных вызовах, таких как операции с сокетами или сетевые запросы, также приводили к переключению контекста.\n3. **Вручную вызванные точки прерывания:**\n    \n    - При явном вызове `runtime.Gosched()`, горутина могла передать управление другой горутине, позволяя другим задачам выполняться.\n4. **Блокировки:**\n    \n    - Когда горутина блокировалась на мьютексе или других примитивах синхронизации, планировщик мог переключить контекст.\n5. **Завершение горутины:**\n    \n    - Когда горутина завершалась (например, выполняя `return` или достигнув конца функции), планировщик переключал контекст на другую горутину.\n6. **Работа с каналами:**\n    \n    - Ожидание или передача значений через каналы, если канал был пуст или заполнен, могло вызвать переключение контекста. Когда горутина блокировалась на канале, управление передавалось другим горутинам.\n7. **Таймеры:**\n    \n    - Планировщик мог переключить контекст, если горутина ожидала таймер, например, через `time.Sleep()` или другие подобные вызовы.\n\nДо версии 1.15 планировщик был кооперативным, и горутина могла передавать управление только в этих конкретных точках. В Go 1.14 и 1.15 улучшили механизмы планирования, добавив вытесняющее планирование для предотвращения зависания долгих горутин, что позволило улучшить производительность и отзывчивость системы.","x":-2009,"y":1000,"width":709,"height":860},
		{"id":"038bbd60bf9199bd","type":"text","text":"Планировщик Go использует алгоритм work stealing для балансировки нагрузки между P. Если LRQ одного P пуста, он может попытаться украсть горутину из LRQ или GRQ другого P. Это позволяет эффективно использовать ресурсы и избегать простоя.","x":340,"y":-156,"width":386,"height":261},
		{"id":"807eb7034ea2eba7","type":"text","text":"Зависит от системы, команда GOMAXPROCS","x":-960,"y":-1160,"width":299,"height":74}
	],
	"edges":[
		{"id":"3a782bfb0b6e8ce3","fromNode":"161b28a1b06f9c5e","fromSide":"top","toNode":"0cc083647a5c7007","toSide":"bottom","label":"под капотом"},
		{"id":"087c653998616d9b","fromNode":"161b28a1b06f9c5e","fromSide":"right","toNode":"038bbd60bf9199bd","toSide":"left","label":"принцип работы"},
		{"id":"a3512f741ff74d87","fromNode":"161b28a1b06f9c5e","fromSide":"bottom","toNode":"ab05a03cadfec8c5","toSide":"top","label":"тип планировщика"},
		{"id":"7360b2dc4c9865c5","fromNode":"161b28a1b06f9c5e","fromSide":"left","toNode":"5f35a01103c582d4","toSide":"right"},
		{"id":"987e205d357e0edf","fromNode":"5f35a01103c582d4","fromSide":"left","toNode":"57d82cef1223c890","toSide":"right","label":"Можно ли руками переключить контекст горутины?"},
		{"id":"4d9886c78c5b8caf","fromNode":"5f35a01103c582d4","fromSide":"left","toNode":"9e41c95e22d79a1f","toSide":"right","label":"Сколько потоков операционной системы мы можем создать"},
		{"id":"53c1863e421f722b","fromNode":"5f35a01103c582d4","fromSide":"left","toNode":"a66eb1eff1e2b3e8","toSide":"right","label":"Расскажи про глобальную и локальную очереди"},
		{"id":"2cd3bf4de1a91c6f","fromNode":"0cc083647a5c7007","fromSide":"right","toNode":"213f503a7041710d","toSide":"left","label":"модель"},
		{"id":"99fb97b52ca8f8b6","fromNode":"ab05a03cadfec8c5","fromSide":"bottom","toNode":"683cde9ce5e8ca4f","toSide":"top"},
		{"id":"c5df5c050a4e2000","fromNode":"ab05a03cadfec8c5","fromSide":"right","toNode":"a6c27932d4dbb864","toSide":"top","label":"разница с кооперативным длинно"},
		{"id":"a3e295affce0ec49","fromNode":"0cc083647a5c7007","fromSide":"left","toNode":"807eb7034ea2eba7","toSide":"bottom","label":"Сколько потоков операционной системы мы можем создать?"},
		{"id":"aedae1dc1a3b2a4c","fromNode":"5f35a01103c582d4","fromSide":"bottom","toNode":"aa9e7d5504923883","toSide":"right","label":"В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?"}
	]
}