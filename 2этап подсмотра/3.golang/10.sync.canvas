{
	"nodes":[
		{"id":"94574cfe342030e8","type":"text","text":"Примитивы синхронизации","x":-104,"y":-100,"width":184,"height":80},
		{"id":"d80854d526671cc8","type":"text","text":"package sync ","x":-95,"y":-260,"width":167,"height":50},
		{"id":"c5739dfe648cab5d","type":"text","text":"context","x":-71,"y":40,"width":118,"height":50},
		{"id":"045cd95230d78f2e","type":"text","text":"содержит примитивы для управления жизненным циклом и отменой горутин (goroutines), а также для передачи метаданных между ними.","x":-182,"y":221,"width":341,"height":148},
		{"id":"73b06cd494dc6868","type":"text","text":"channel","x":-368,"y":-92,"width":135,"height":64},
		{"id":"335ed73139e1d03d","type":"text","text":"является встроенным типом данных, который представляет собой канал для обмена данными между горутинами, который может быть использован как примитив синхронизации или коммуникации.","x":-820,"y":-146,"width":379,"height":172},
		{"id":"2dfb0d73c6ed8553","type":"text","text":"Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?","x":-1064,"y":-399,"width":479,"height":82},
		{"id":"3793472fe9919212","type":"text","text":"Чтобы получить тысячу в конце, нужно синхронизировать доступ к общей переменной, которая хранит инт. Для этого можно использовать один из следующих способов:\n\n- Использовать мьютекс (mutex) из пакета sync, который позволяет блокировать и разблокировать доступ к переменной. Каждая горутина должна вызвать метод Lock перед инкрементом и метод Unlock после него, чтобы гарантировать, что только одна горутина может работать с переменной в один момент времени.\n- Использовать атомик (atomic) из пакета sync/atomic, который позволяет выполнять атомарные операции с примитивными типами данных. Вместо обычного инкремента можно использовать функцию AddInt32 или AddInt64, которая атомарно увеличивает значение переменной на заданное число и возвращает новое значение.","x":-1840,"y":-544,"width":649,"height":378},
		{"id":"31a099f1d9aca52e","type":"text","text":"Мьютекс имеет только два состояния: заблокирован или разблокирован","x":-1387,"y":-1000,"width":305,"height":100},
		{"id":"7cb7c7004ac24e8d","type":"text","text":"Мьютексы работают с любыми типами данных","x":-1405,"y":-1072,"width":321,"height":72},
		{"id":"b8e485e17f4886c6","type":"text","text":"Мьютекс может быть захвачен или освобожден только тем потоком, который его заблокировал","x":-1425,"y":-900,"width":341,"height":86},
		{"id":"7da38cc948c1f6f4","type":"text","text":"Мьютекс обычно используется для взаимного исключения, т.е. для предотвращения состояний гонки","x":-1387,"y":-814,"width":297,"height":135},
		{"id":"d11ed1d0a59ba8dd","type":"text","text":"Мьютекс - это объект, который позволяет блокировать и разблокировать доступ к одному ресурсу","x":-820,"y":-900,"width":311,"height":135},
		{"id":"434cf05c1ec29a55","type":"text","text":"sync.Map - потокобезопасный аналог map, но более медленный","x":-140,"y":-940,"width":254,"height":119},
		{"id":"d37e01c0ad07505f","type":"text","text":"sync.Map может быть полезен, если у вас высоконагруженная система с большим количеством ядер процессора (32+), и вы сталкиваетесь с проблемой ложной разделяемости (false sharing), когда разные горутины конкурируют за доступ к одному и тому же кеш-линии (cache line). В этом случае sync.Map может снизить количество конфликтов и повысить скорость работы с картой.\n\nОднако, если у вас небольшое количество ядер (меньше 8), и вы часто записываете в карту, то sync.Map может быть неэффективнее, чем обычная карта с мьютексом, так как он использует сложную внутреннюю структуру, которая требует дополнительных вычислений и памяти.\n\nТаким образом, нет однозначного ответа на вопрос, сколько нужно ядер, чтобы начать использовать sync.Map. Это зависит от конкретной задачи, характера операций с картой, нагрузки на систему и других факторов. ","x":-281,"y":-1711,"width":536,"height":484},
		{"id":"0c0ed4b4490bf2e8","type":"text","text":"Состояние гонки означает, что результат работы программы зависит от случайного порядка выполнения операций, и может быть непредсказуемым или некорректным. ","x":-820,"y":-1940,"width":398,"height":148},
		{"id":"b6c648b8240c8848","type":"text","text":"Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?","x":-831,"y":-1680,"width":420,"height":117},
		{"id":"6e4f60c1dc303c3e","type":"text","text":"Mutex и RWMutex в Go оба используются для синхронизации доступа к данным в многопоточной среде, но они работают немного по-разному:\n\nMutex:\n- Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.\n- Если другая горутина пытается получить доступ к данным, когда Mutex заблокирован, она будет заблокирована до тех пор, пока Mutex не будет разблокирован.\n  \nRWMutex:\n- RWMutex (Reader-Writer Mutex) предоставляет более гибкую семантику блокировки.\n- RWMutex позволяет множеству горутин получить параллельный доступ для чтения (блокировка чтения), но только одной горутине получить эксклюзивный доступ на запись (блокировка записи).\nЭто означает, что несколько горутин могут одновременно читать данные, но запись данных может производить только одна горутина.","x":-1720,"y":-1980,"width":528,"height":620},
		{"id":"279017e11b6c647d","type":"text","text":"Использование Mutex:\n- Mutex следует использовать, когда у вас есть данные, которые могут быть изменены одновременно несколькими горутинами.\n- Mutex обеспечивает взаимоисключающую блокировку, что позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.\n\nИспользование RWMutex:\n- RWMutex следует использовать, когда у вас есть данные, которые часто читаются, но редко обновляются.\n- RWMutex позволяет множеству горутин получить параллельный доступ для чтения, но только одной горутине получить эксклюзивный доступ на запись.\nЭто может улучшить производительность, если у вас есть данные, которые часто читаются, так как несколько горутин могут одновременно читать данные","x":-1726,"y":-2720,"width":540,"height":480},
		{"id":"74fe85aef54f504e","type":"text","text":"Не встраивать в поле структуры","x":-1340,"y":-1137,"width":250,"height":60},
		{"id":"0c102f51f4e0f0d5","type":"text","text":"содержит базовые примитивы, такие как мьютексы (mutexes), блокировки чтения-записи (read-write locks), группы ожидания (wait groups), однократные исполнители (once), условные переменные (condition variables) и другие","x":-207,"y":-598,"width":391,"height":184},
		{"id":"8920f5bc437395d7","type":"text","text":"Под капотом WaitGroup реализован с помощью атомарных операций, которые обеспечивают потокобезопасность и высокую производительность. WaitGroup использует 64-битное целое число, которое разделено на две части: старшие 32 бита хранят счетчик горутин, а младшие 32 бита хранят счетчик ожидающих горутин. \n\nКаждый раз, когда вызывается метод Add, WaitGroup атомарно увеличивает счетчик горутин на заданное значение. Каждый раз, когда вызывается метод Done, WaitGroup атомарно уменьшает счетчик горутин на единицу и проверяет, не стал ли он равным нулю. Если да, то WaitGroup атомарно увеличивает счетчик ожидающих горутин на единицу и разблокирует одну из ожидающих горутин с помощью сигнальной переменной (signal variable). \n\nКаждый раз, когда вызывается метод Wait, WaitGroup атомарно уменьшает счетчик ожидающих горутин на единицу и проверяет, не стал ли он отрицательным. Если да, то WaitGroup атомарно возвращает счетчик ожидающих горутин в исходное состояние и блокирует текущую горутину с помощью сигнальной переменной.","x":1129,"y":-1866,"width":558,"height":554},
		{"id":"533101e35d1cab7b","type":"text","text":"WaitGroup позволяет организовать синхронизацию между несколькими горутинами, которые выполняют параллельные или конкурентные задачи. WaitGroup имеет счетчик, который увеличивается при добавлении новой горутины и уменьшается при ее завершении. Основная горутина может вызвать метод Wait, который блокирует ее до тех пор, пока счетчик не станет равным нулю, то есть пока все горутины не закончат свою работу","x":1178,"y":-1102,"width":460,"height":270},
		{"id":"cfcd374997e3b3ba","type":"text","text":"**Delete(key any)**: удаляет элемент по ключу;\n\n**Load(key any) (value any, ok bool)**: извлекает значение по ключу;\n\n**LoadAndDelete(key any) (value any, loaded bool)**: извлекает и одновременно удаляет элемент;\n\n**LoadOrStore(key, value any) (actual any, loaded bool)**: извлекает значение или сохраняет новое, если ключ отсутствует;\n\n**Range(f func(key, value any) bool)**: выполняет функцию для каждого элемента мапы;\n\n**Store(key, value any)**: сохраняет пару ключ-значение.","x":-411,"y":-2385,"width":441,"height":445},
		{"id":"59dfb803fcad94fa","type":"text","text":"**Cache contention** (конкуренция за кеш) возникает, когда несколько процессоров или горутин пытаются одновременно получить доступ к данным, которые хранятся в кешах, что может привести к замедлению работы из-за избыточной синхронизации и блокировок. Это особенно актуально в многопроцессорных системах, где кеши процессоров могут не синхронизироваться должным образом.","x":120,"y":-2385,"width":375,"height":313},
		{"id":"a108a925042ae764","type":"text","text":"содержит функции для атомарных операций с примитивными типами данных, такими как целые числа, указатели, булевы значения и т.д.","x":940,"y":-598,"width":335,"height":144},
		{"id":"1700399e87ab7dbd","type":"text","text":"В общем, мьютексы и атомики имеют следующие отличия:\n- Мьютексы работают с любыми типами данных, а атомики - только с примитивными типами, такими как int, uint, bool, pointer и т.д.\n- Мьютексы требуют явной блокировки и разблокировки, а атомики - нет.\n- Мьютексы позволяют выполнять любые операции с ресурсом, а атомики - только ограниченный набор операций.\n- Мьютексы могут быть более медленными и затратными, чем атомики, из-за переключения контекста и ожидания блокировки.\n- Мьютексы могут приводить к взаимным блокировкам (deadlocks), если не использовать их правильно, а атомики - нет.\n  - **Мьютекс** — используется для блокировки и синхронизации доступа к ресурсам, предотвращая одновременный доступ нескольких горутин.\n- **Атомики** — обеспечивают **атомарные операции** над переменными (например, инкремент, декремент), без блокировки, для безопасного изменения данных без гонок.\n\n**Отличие:** Мьютексы блокируют доступ к данным, атомики — выполняют операции без блокировки.","x":1900,"y":-1166,"width":568,"height":640},
		{"id":"ceb4222d8cb046f1","type":"text","text":"Атомики (atomics) - это функции, которые позволяют выполнять простые операции с общим ресурсом, такие как чтение, запись, инкремент, декремент, обмен или сравнение и присваивание. Атомики гарантируют, что эти операции будут выполнены атомарно, то есть без вмешательства других горутин. Атомики реализованы в пакете sync/atomic, и для их использования нужно вызывать соответствующие функции с указателем на ресурс. Атомики подходят для ситуаций, когда требуется выполнить быстрые и простые операции с ресурсом, такие как увеличение или уменьшение счетчика, установка или сброс флага, или проверка или изменение состояния","x":1560,"y":-454,"width":515,"height":332},
		{"id":"a0bc6742fb8642bd","type":"text","text":"1. **sync.Pool**:\n    \n    - Это пул объектов, предназначенный для повторного использования объектов, чтобы избежать их частой аллокации и освобождения памяти. Это помогает уменьшить накладные расходы на управление памятью в многопоточных приложениях.\n    - **Пример использования**: Используется для кеширования объектов, таких как буферы, которые часто создаются и уничтожаются.\n2. **sync.Once**:\n    \n    - Это структура, гарантирующая, что определённая операция будет выполнена только один раз, независимо от того, сколько раз она будет вызвана. Это полезно для инициализации ресурсов или однократных действий.\n    - **Пример использования**: Инициализация глобальных настроек или подключений к базе данных.\n3. **sync.Cond**:\n    \n    - Это условная переменная, которая используется для синхронизации горутин. Она позволяет одной горутине сигнализировать другой горутине о том, что условие для продолжения работы выполнено.\n    - **Пример использования**: Ожидание события (например, получения данных) или выполнение действия по сигналу (например, завершение операции).","x":495,"y":-1986,"width":536,"height":795},
		{"id":"72293bee4178e0bd","type":"text","text":"- **Мьютекс** — позволяет только одной горутине получить доступ к ресурсу за раз, используется для **взаимного исключения**.\n- **Семафор** — ограничивает доступ к ресурсу, позволяя нескольким горутинам работать одновременно, но с ограничением на количество.","x":1261,"y":436,"width":436,"height":208},
		{"id":"a9a77d0136b72957","type":"text","text":"semaphore","x":985,"y":224,"width":144,"height":50},
		{"id":"1219a535b15f1fd3","type":"text","text":"семафор - это переменная, которая позволяет контролировать доступ к нескольким ресурсам","x":1337,"y":229,"width":328,"height":115},
		{"id":"59fc7b5cecda640a","type":"text","text":"имеет целочисленное значение, которое может быть больше нуля","x":632,"y":-100,"width":285,"height":101},
		{"id":"c0bf8f622ec32f77","type":"text","text":"семафор может быть изменен любым потоком","x":917,"y":-100,"width":281,"height":94},
		{"id":"769d8151dba85f99","type":"text","text":"семафор обычно используется для координации, т.е. для синхронизации действий между потоками","x":1198,"y":-100,"width":320,"height":132},
		{"id":"dc559dc1b14cf99e","type":"text","text":"Один из способов сделать это - использовать семафор (semaphore), который представляет собой переменную, которая хранит количество доступных ресурсов. Семафор может быть реализован с помощью канала (channel) с буфером размера N, который будет заполнен пустыми значениями.\n\nКаждая горутина, которая хочет получить доступ к ресурсу, должна сначала получить значение из канала, а затем вернуть его обратно после завершения работы. Таким образом, канал будет выступать в роли блокировки, которая разрешает доступ только N горутинам одновременно.","x":2300,"y":92,"width":643,"height":252}
	],
	"edges":[
		{"id":"3349eba8bf1eeb14","fromNode":"94574cfe342030e8","fromSide":"top","toNode":"d80854d526671cc8","toSide":"bottom"},
		{"id":"fd27b9658a566cab","fromNode":"d80854d526671cc8","fromSide":"top","toNode":"0c102f51f4e0f0d5","toSide":"bottom"},
		{"id":"7b78af28a34a3a23","fromNode":"94574cfe342030e8","fromSide":"bottom","toNode":"c5739dfe648cab5d","toSide":"top"},
		{"id":"76d56e412ead2ee2","fromNode":"c5739dfe648cab5d","fromSide":"bottom","toNode":"045cd95230d78f2e","toSide":"top"},
		{"id":"336279e082ed4097","fromNode":"94574cfe342030e8","fromSide":"left","toNode":"73b06cd494dc6868","toSide":"right"},
		{"id":"bf2367b0e7ca325e","fromNode":"73b06cd494dc6868","fromSide":"left","toNode":"335ed73139e1d03d","toSide":"right"},
		{"id":"7b2f02cf45c212fc","fromNode":"0c102f51f4e0f0d5","fromSide":"top","toNode":"d11ed1d0a59ba8dd","toSide":"bottom","label":"mutex"},
		{"id":"e6e3890bee38cea3","fromNode":"a9a77d0136b72957","fromSide":"right","toNode":"1219a535b15f1fd3","toSide":"left","label":"что это"},
		{"id":"922136db41c75a7d","fromNode":"d11ed1d0a59ba8dd","fromSide":"left","toNode":"b8e485e17f4886c6","toSide":"right"},
		{"id":"294cf66e9a1799ea","fromNode":"a9a77d0136b72957","fromSide":"top","toNode":"c0bf8f622ec32f77","toSide":"bottom","label":"факт"},
		{"id":"5f00fa62d5225a47","fromNode":"d11ed1d0a59ba8dd","fromSide":"left","toNode":"7da38cc948c1f6f4","toSide":"right"},
		{"id":"f00b4dde9ef625a3","fromNode":"a9a77d0136b72957","fromSide":"top","toNode":"769d8151dba85f99","toSide":"bottom"},
		{"id":"3264354c378230ea","fromNode":"d11ed1d0a59ba8dd","fromSide":"left","toNode":"31a099f1d9aca52e","toSide":"right"},
		{"id":"8de73e1813706130","fromNode":"d11ed1d0a59ba8dd","fromSide":"left","toNode":"7cb7c7004ac24e8d","toSide":"right"},
		{"id":"5e0a20d9a9e5b308","fromNode":"0c102f51f4e0f0d5","fromSide":"top","toNode":"533101e35d1cab7b","toSide":"bottom","label":"WaitGroup"},
		{"id":"fde41da5a936d339","fromNode":"1219a535b15f1fd3","fromSide":"right","toNode":"dc559dc1b14cf99e","toSide":"left","label":"Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?"},
		{"id":"0fd188104549c5e9","fromNode":"d80854d526671cc8","fromSide":"left","toNode":"2dfb0d73c6ed8553","toSide":"right","label":"вопрос про кучу горутин"},
		{"id":"5964a6e2f5b0b412","fromNode":"2dfb0d73c6ed8553","fromSide":"left","toNode":"3793472fe9919212","toSide":"right"},
		{"id":"ec27de3887bd7a79","fromNode":"d11ed1d0a59ba8dd","fromSide":"top","toNode":"b6c648b8240c8848","toSide":"bottom","label":"вопрос про блок"},
		{"id":"6addc69254574237","fromNode":"b6c648b8240c8848","fromSide":"top","toNode":"0c0ed4b4490bf2e8","toSide":"bottom"},
		{"id":"c9846feeb1face0f","fromNode":"0c102f51f4e0f0d5","fromSide":"top","toNode":"434cf05c1ec29a55","toSide":"bottom","label":"sync.map"},
		{"id":"1697a5c097fbc5e8","fromNode":"434cf05c1ec29a55","fromSide":"top","toNode":"d37e01c0ad07505f","toSide":"bottom","label":"Сколько нужно ядер, чтобы начать использовать sync.Map"},
		{"id":"26d096edcd265abd","fromNode":"533101e35d1cab7b","fromSide":"top","toNode":"8920f5bc437395d7","toSide":"bottom","label":"Как устроена WaitGroup под капотом и как ее можно реализовать самому?"},
		{"id":"eb4e9608fa168007","fromNode":"d11ed1d0a59ba8dd","fromSide":"top","toNode":"6e4f60c1dc303c3e","toSide":"right","label":"В чем разница между Mutex и RWMutex"},
		{"id":"b43c64cbe1ca7831","fromNode":"6e4f60c1dc303c3e","fromSide":"top","toNode":"279017e11b6c647d","toSide":"bottom","label":"Когда нужно использовать Mutex, а когда RWMutex?"},
		{"id":"f1b061342df0dd7d","fromNode":"d11ed1d0a59ba8dd","fromSide":"left","toNode":"74fe85aef54f504e","toSide":"right"},
		{"id":"f75627deda656366","fromNode":"0c102f51f4e0f0d5","fromSide":"top","toNode":"a0bc6742fb8642bd","toSide":"bottom","label":"sync.Once, Pool, Cond"},
		{"id":"1df45733c646702f","fromNode":"d37e01c0ad07505f","fromSide":"top","toNode":"cfcd374997e3b3ba","toSide":"bottom","label":"методы"},
		{"id":"9d0a5725ce49a22c","fromNode":"d37e01c0ad07505f","fromSide":"top","toNode":"59dfb803fcad94fa","toSide":"bottom","label":"Cache contention или почему лучше syncMap"},
		{"id":"6bcefd6e75825971","fromNode":"a9a77d0136b72957","fromSide":"bottom","toNode":"72293bee4178e0bd","toSide":"left","label":"отличие от Mutex"},
		{"id":"466560680d43cac9","fromNode":"a108a925042ae764","fromSide":"right","toNode":"1700399e87ab7dbd","toSide":"left","label":"различия с mutex"},
		{"id":"91453c0294b466c0","fromNode":"0c102f51f4e0f0d5","fromSide":"top","toNode":"a108a925042ae764","toSide":"left","label":"Atomic"},
		{"id":"2a5e94a83a439c55","fromNode":"a108a925042ae764","fromSide":"right","toNode":"ceb4222d8cb046f1","toSide":"top","label":"пояснение"},
		{"id":"0f0db60908f652d9","fromNode":"a9a77d0136b72957","fromSide":"top","toNode":"59fc7b5cecda640a","toSide":"bottom"},
		{"id":"2620e4bf2818163d","fromNode":"94574cfe342030e8","fromSide":"right","toNode":"a9a77d0136b72957","toSide":"left","label":"cемафор"}
	]
}