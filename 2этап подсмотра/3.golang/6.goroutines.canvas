{
	"nodes":[
		{"id":"246f1036ddd62d3a","type":"text","text":"goroutine","x":-233,"y":-67,"width":153,"height":67},
		{"id":"d668c7b9ec704e72","type":"text","text":"Легковесные потоки в Го (от 2кб), которые контролируются на уровне программы, а не системы. На одном потоке может исполняться несколько горутин. Выполняется Go runtime, Горутины обычно запускаются и выполняются в одном процессе, и их число не ограничено количеством доступных процессоров или потоков операционной системы. Переключение контекста горутин происходит в рантайме Go. Это переключение происходит, когда горутина ожидает ввода/вывода, блокирует канал, или вызывает `runtime.Gosched()`. Оно происходит быстро и с минимальными накладными расходами.","x":-642,"y":-740,"width":423,"height":400},
		{"id":"3a51c80f91bbacef","type":"text","text":"это легковесные потоки, управляемые Go-рантаймом, которые могут эффективно выполняться в рамках одного процесса, потребляя меньше ресурсов и позволяя создавать тысячи или миллионы параллельных задач.","x":-59,"y":-570,"width":318,"height":230},
		{"id":"8e0d0e425d0ecbf3","type":"text","text":"runtime.Gosched()","x":-642,"y":391,"width":250,"height":60},
		{"id":"5b3faac69b79a977","type":"text","text":"Используется вытесняющий тип планировщика в Го","x":-380,"y":57,"width":295,"height":86},
		{"id":"3357d0f80939cfda","type":"text","text":"Для синхронизации используются каналы","x":200,"y":-240,"width":250,"height":60},
		{"id":"fcfee7d3586b0a78","type":"text","text":"В Go существует несколько способов связи между горутинами, и каждый из них имеет свои плюсы и минусы. Вот основные способы связи:\n\n### 1. **Каналы (Channels)**\n\nКаналы — это основной механизм связи между горутинами в Go. Они позволяют передавать данные между горутинами с использованием синхронизации.\n\n**Плюсы:**\n\n- **Простота:** Каналы интегрированы в язык Go и легко использовать для синхронизации горутин.\n- **Безопасность:** Каналы автоматически синхронизируют доступ к данным, предотвращая гонки данных (data races).\n- **Чистота кода:** Использование каналов способствует чистому и понятному коду, что упрощает поддержку и масштабируемость.\n- **Блокировка и синхронизация:** Каналы блокируют горутину, пока другая горутина не передаст или не получит данные, что позволяет синхронизировать выполнение.\n\n**Минусы:**\n\n- **Неприятности с производительностью:** Если каналы используются неправильно, например, без буферизации или с частыми блокировками, это может привести к снижению производительности.\n- **Сложности при использовании с большими данными:** Для передачи больших структур данных через каналы может потребоваться больше памяти и времени на сериализацию/десериализацию.\n- **Риск мертвых блокировок:** Каналы могут привести к зависаниям (deadlocks), если одна горутина ожидает данных, которые никогда не будут переданы.\n\n---\n\n### 2. **Мьютексы (Mutexes) и другие примитивы синхронизации**\n\nМьютексы (и их расширения, такие как `sync.RWMutex`) используются для синхронизации доступа к разделяемым данным.\n\n**Плюсы:**\n\n- **Простота и контроль:** Мьютексы позволяют точно контролировать, какие горутины могут одновременно работать с данными.\n- **Гибкость:** Мьютексы подходят для использования в более сложных случаях синхронизации, например, при работе с общими переменными или ресурсами.\n\n**Минусы:**\n\n- **Гонки данных:** Если мьютексы не используются правильно (например, при забывчивости о блокировке/разблокировке), могут возникнуть гонки данных.\n- **Низкая производительность при частых блокировках:** Мьютексы могут привести к значительным накладным расходам, если слишком часто блокируются или разблокируются.\n\n---\n\n### 3. **Сигналы и События (Signals and Events)**\n\nДля уведомления горутин можно использовать каналы или другие синхронизирующие примитивы, такие как `sync.Cond` (условные переменные).\n\n**Плюсы:**\n\n- **Гибкость:** Сигналы могут быть полезны для управления состоянием между горутинами (например, для ожидания событий).\n- **Реализация паттернов проектирования:** Удобны для реализации таких паттернов как \"производитель-потребитель\", \"наблюдатель\" и других.\n\n**Минусы:**\n\n- **Сложность:** Управление сигналами и событиями может быть более сложным, чем простое использование каналов.\n- **Мертвая блокировка:** При неправильном использовании (например, без должного оповещения горутин) могут возникать проблемы с блокировкой.\n\n---\n\n### 4. **Global Shared State (Глобальные переменные)**\n\nГорутине можно передавать данные через глобальные переменные, которые могут быть изменены несколькими горутинами.\n\n**Плюсы:**\n\n- **Простота:** Это решение может быть простым, если горутины не делают слишком сложные изменения в состоянии.\n- **Гибкость:** Глобальные переменные позволяют использовать общие данные, доступные всем горутинам.\n\n**Минусы:**\n\n- **Гонки данных:** Если доступ к глобальной переменной не синхронизирован (например, с помощью мьютекса), могут возникнуть гонки данных.\n- **Трудность масштабирования:** Глобальные переменные могут привести к сложным зависимостям и ошибкам, что затрудняет масштабирование и поддержание кода.\n\n---\n\n### 5. **Семафоры (Semaphores)**\n\nСемафоры можно использовать для управления количеством одновременно выполняющихся горутин, ограничивая доступ к определенным ресурсам.\n\n**Плюсы:**\n\n- **Контроль над ресурсами:** Позволяет ограничить количество горутин, которые могут одновременно работать с определенными ресурсами.\n- **Подходит для ограничения параллелизма:** Хорошо подходит для задач, где важно контролировать нагрузку на систему.\n\n**Минусы:**\n\n- **Сложность:** Управление семафорами может быть сложным, особенно при необходимости поддержания точного количества активных горутин.\n- **Мертвые блокировки:** Некорректное использование может привести к зависаниям, если семафоры не освобождаются правильно.\n\n---\n\n### 6. **Барьер (Barrier)**\n\nБарьер используется для синхронизации группы горутин, заставляя их ожидать, пока все не достигнут определенной точки.\n\n**Плюсы:**\n\n- **Синхронизация по этапам:** Хорошо подходит для задач, где нужно синхронизировать выполнение нескольких этапов.\n- **Управление группами горутин:** Удобен для операций, требующих одновременного старта или завершения нескольких горутин.\n\n**Минусы:**\n\n- **Сложность:** Барьеры могут быть сложными в реализации, если горутины имеют разные рабочие циклы.\n- **Мертвые блокировки:** Если не настроены правильно, барьеры могут привести к блокировкам, если одна или несколько горутин не могут пройти через барьер.\n\n---\n\n### Вывод:\n\nКаждый способ связи между горутинами имеет свои особенности, и выбор зависит от конкретных требований задачи. Каналы обычно считаются предпочтительным вариантом для большинства случаев в Go из-за их простоты и встроенной синхронизации, но в некоторых случаях мьютексы, семафоры или другие примитивы синхронизации могут быть более эффективными или необходимыми для контроля более сложных сценариев.","x":1631,"y":-3745,"width":800,"height":3345},
		{"id":"239eb8f546cc0100","type":"text","text":"Флаг --race при запуске","x":1341,"y":210,"width":250,"height":50},
		{"id":"e4f989053a1e8d0e","type":"text","text":"Делает нагрузку на программу больше","x":1781,"y":70,"width":250,"height":60},
		{"id":"70abad62c2172172","type":"text","text":"Проблемы при использовании каналов и горутин в Go могут возникать из-за:\n\n1. **Гонок данных (Data races)**: Несинхронизированный доступ к общим данным из нескольких горутин.\n2. **Блокировки (Deadlocks)**: Когда горутины ждут друг друга, но ни одна не может продолжить выполнение.\n3. **Необработанные ошибки**: Ошибки в горутинах могут оставаться незамеченными, если они не обрабатываются корректно.\n4. **Неверное использование буферизированных каналов**: Ошибки при отправке или получении данных, если канал переполнен или пуст.\n5. **Невозможность закрытия канала**: Если канал не закрыт после использования, другие горутины могут зависать, ожидая данных.","x":280,"y":160,"width":438,"height":517},
		{"id":"3ed4ab8fa2e212cc","type":"text","text":"Не всегда находит все гонки, но если нашёл - это точно они","x":1771,"y":235,"width":271,"height":107}
	],
	"edges":[
		{"id":"79b3e56884ffd3fd","fromNode":"246f1036ddd62d3a","fromSide":"top","toNode":"d668c7b9ec704e72","toSide":"bottom","label":"это длинно"},
		{"id":"844a057515aa90ec","fromNode":"246f1036ddd62d3a","fromSide":"bottom","toNode":"5b3faac69b79a977","toSide":"top"},
		{"id":"2fb67d0be32bdb90","fromNode":"5b3faac69b79a977","fromSide":"bottom","toNode":"8e0d0e425d0ecbf3","toSide":"top","label":"самостоятельно переключить горутину"},
		{"id":"151846fd7e8b95e4","fromNode":"246f1036ddd62d3a","fromSide":"right","toNode":"3357d0f80939cfda","toSide":"left"},
		{"id":"d5d3d62fb8a5c0fa","fromNode":"246f1036ddd62d3a","fromSide":"right","toNode":"70abad62c2172172","toSide":"left","label":"проблемы/ошибки"},
		{"id":"bf42f46ce0e160a3","fromNode":"70abad62c2172172","fromSide":"right","toNode":"239eb8f546cc0100","toSide":"left","label":"как отследить Data race"},
		{"id":"acb539bade9307e3","fromNode":"239eb8f546cc0100","fromSide":"right","toNode":"e4f989053a1e8d0e","toSide":"left"},
		{"id":"64eae74bd042a231","fromNode":"246f1036ddd62d3a","fromSide":"top","toNode":"3a51c80f91bbacef","toSide":"bottom","label":"это коротко"},
		{"id":"13edf8da6ce12129","fromNode":"246f1036ddd62d3a","fromSide":"right","toNode":"fcfee7d3586b0a78","toSide":"left","label":"cпособы связи"},
		{"id":"0efc5ff1e666a4d3","fromNode":"239eb8f546cc0100","fromSide":"right","toNode":"3ed4ab8fa2e212cc","toSide":"left"}
	]
}