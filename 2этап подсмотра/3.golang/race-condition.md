---
title: Гонка данных
---

## Что такое race condition?

Состояние гонки (англ. race condition), также известное как конкуренция, - это ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Это может произойти, когда две или более операций должны выполняться в последовательности, но из-за неконтролируемых событий они выполняются в непредсказуемом порядке. В результате система или приложение может вести себя непредсказуемо или даже вызывать сбои.

Состояние гонки - это “плавающая” ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и “пропадающая” при попытке её локализовать. Из-за неконтролируемого доступа к общей памяти состояние гонки может приводить к совершенно различным ошибкам, которые могут проявляться в непредсказуемые моменты времени, а попытка повторения ошибки в целях отладки со схожими условиями работы может оказаться безуспешной.

Основными последствиями могут быть: утечки памяти, ошибки сегментирования, порча данных, уязвимости, взаимные блокировки, утечки других ресурсов, например файловых дескрипторов.

Источники:
- [Habr](https://habr.com/ru/articles/764234/)

## Как обнаружить race condition?
В Go есть встроенный инструмент для обнаружения состояний гонки, который можно использовать при запуске или сборке вашего приложения. Вы можете использовать флаг `-race` для обнаружения состояний гонки. Например, если ваш файл называется `write.go`, команда будет выглядеть так: `go run -race write.go` или `go build -race write.go`.

При запуске этой команды Go выводит на стандартный вывод, который сообщает нам о наличии состояния гонки. Это очень полезный инструмент для обнаружения и исправления состояний гонки в ваших программах на Go.

Также стоит отметить, что состояния гонки могут быть сложными для обнаружения и воспроизведения, поскольку они могут проявляться только при определенных условиях выполнения и могут не проявляться при повторном запуске того же кода. Поэтому использование инструментов, таких как детектор состояний гонки в Go, может быть очень полезным.

## Какие есть способы устранения race condition?

- Использование Mutex: (RW)Mutex предоставляет взаимоисключающую блокировку, которая позволяет только одной горутине в любой момент времени иметь доступ к защищенным данным.
- Использование каналов: Каналы в Go обеспечивают синхронизацию между горутинами и могут быть использованы для предотвращения состояний гонки.
- Использование атомарных операций: Пакет sync/atomic в Go предоставляет функции для атомарных операций, которые могут быть использованы для безопасного доступа к данным из нескольких горутин.

## Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?

Да, будет состояние гонки. Функция append не является потокобезопасной, и если вы пытаетесь одновременно добавить элементы в слайс из разных горутин, это может привести к состоянию гонки.

В Go, когда вы вызываете append, он может изменить размер слайса. Если размер нового слайса больше текущей вместимости, Go создаст новый массив в памяти и скопирует в него все элементы. Если две горутины одновременно пытаются добавить элементы, они могут получить разные копии массива, что приведет к непредсказуемым результатам.

Чтобы избежать состояния гонки, вы можете использовать мьютекс (sync.Mutex или sync.RWMutex) для синхронизации доступа к слайсу.

## Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?

Да, будет гонка данных. В Go, горутины выполняются параллельно, и если они обе пытаются изменить одну и ту же переменную (в данном случае, глобальный слайс), это может привести к неопределенному поведению. Это известно как гонка данных.

Чтобы избежать этого, вы можете использовать мьютексы или каналы для синхронизации доступа к общим ресурсам.
