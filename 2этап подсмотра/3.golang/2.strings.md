---
title: Строки
---

## Что такое string или строки?

Строка в golang - это неизменяемая последовательность байт, которая представляет собой текстовые данные(состоит из массива byte).

```go 
var s string = "hello"
// или сокращенная запись
s := "hey"
```

Под капотом:
```go
type string struct {
    Data *byte
    Len  int
}

```
Функция len() возращает количество байт, а не рун(символов):
```go
s := "Привет"
fmt.Println(len(s)) // 12
```

Функция utf8.RuneCountInString() возращает количество рун(символов):
```go
import "unicode/utf8"

s := "Привет"
fmt.Println(utf8.RuneCountInString(s)) // 6

```
Правильный обход строки:
```go
for i, r := range s {
    fmt.Printf("символ %c на позиции %d\n", r, i)
}

```
Безопасное обрезание строки по рунам:
```go
runes := []rune(s)
sub := string(runes[:3]) // первые 3 символа
fmt.Println(sub)

```
Пакеты для работы со строками:
```go
import "strings"

strings.Contains("hello", "ll")  // true
strings.ToUpper("hello")         // "HELLO"
strings.Split("a,b,c", ",")      // ["a" "b" "c"]

```

Строки в golang хранят символы в кодировке UTF-8, которая поддерживает множество языков и специальных символов.

Каждый символ в строке называется руной (`rune`), которая является псевдонимом для типа `int32`. Руны можно получать из строк с помощью цикла for-range или функции range, а также преобразовывать в строки с помощью функции `string`.

## Как устроена строка внутри, а точнее reflect.String и reflect.StringHeader?

reflect.String - это псевдоним для типа string, который является неизменяемой последовательностью символов в кодировке UTF-8. 

reflect.StringHeader - это структура, которая содержит два поля: Data и Len. Data - это указатель на первый байт строки, а Len - это длина строки в байтах. Структура reflect.StringHeader может быть получена из строки с помощью функции unsafe.Pointer, которая преобразует любое значение в указатель безопасного типа. Например, можно использовать такой код:

```go 
s := "hello"
sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
fmt.Println(sh.Data, sh.Len) // выводит адрес и длину строки
```

Структура reflect.StringHeader может быть также использована для создания новой строки из существующей, изменяя ее указатель или длину. Например, можно использовать такой код:

```go
s := "hello, world!"
sh := (*reflect.StringHeader)(unsafe.Pointer(&s))
sh.Data += 7 // сдвигаем указатель на 7 байтов
sh.Len -= 7 // уменьшаем длину на 7 байтов
fmt.Println(s) // выводит "world!"
```

Однако, такое использование reflect.StringHeader может быть опасным, так как оно нарушает неизменяемость строк и может привести к непредвиденным ошибкам или поведению. Например, если мы изменим длину строки больше, чем ее емкость, то мы можем получить доступ к памяти, которая не принадлежит строке, и вызвать панику или нарушение сегментации. Также, если мы изменим указатель на данные, то мы можем потерять ссылку на оригинальную строку и вызвать утечку памяти или сборку мусора.

Поэтому, reflect.String и reflect.StringHeader следует использовать с осторожностью и только в тех случаях, когда это необходимо для решения конкретной задачи. В большинстве случаев, можно обойтись стандартными функциями и методами для работы со строками в golang.
