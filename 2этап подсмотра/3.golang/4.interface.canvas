{
	"nodes":[
		{"id":"2634770710bee2d0","type":"text","text":"interface","x":-104,"y":-96,"width":144,"height":56},
		{"id":"4b401c09e391cea3","type":"text","text":"Интерфейс в golang используется для определения набора методов, которые должен реализовывать какой-либо тип данных.\n\nИнтерфейсы позволяют абстрагироваться от конкретных реализаций и работать с разными типами, имеющими общее поведение. Интерфейсы также способствуют модульности, гибкости и переиспользованию кода. Тип автоматически реализует интерфейс, если у него есть нужные методы (нет ключевого слова implements).\n\nНапример, интерфейс fmt.Stringer определяет метод String(), который возвращает строковое представление любого типа, реализующего этот интерфейс. ","x":-263,"y":180,"width":462,"height":440},
		{"id":"43f8384732693ac7","type":"text","text":"Это набор сигнатур методов (то есть список методов без реализации). Можно воспринимать как контракт по которому есть требования и поставщик (структура) должна их реализовывать.","x":-236,"y":-520,"width":409,"height":156},
		{"id":"ee9c04de9938e8d3","type":"text","text":"Пустой интерфейс может содержать значение любого типа (ведь у каждого типа есть как минимум 0 методов)","x":640,"y":-135,"width":320,"height":135},
		{"id":"6c4977ee3704f79b","type":"text","text":"Элиасом пустого интерфейса сделали any с 1.18","x":672,"y":-364,"width":257,"height":116},
		{"id":"a0faed38ce7d4d1c","type":"text","text":"_Приведение типа_ (type assertion) извлекает конкретное значение из переменной интерфейсного типа:\n\n```go\nvar value any = \"hello\"\nstr := value.(string)\nfmt.Println(str)\n// hello\n```\n\nЕсли тип конкретного значения отличается от указанного, произойдет ошибка:\n\n```go\nflo := value.(float64)\n// ошибка\n```\n\nЧтобы проверить тип конкретного значения, используют опциональный флаг, который сигнализирует — правильный тип или нет:\n\n```go\nstr, ok := value.(string)\nfmt.Println(str, ok)\n// hello true\n\nflo, ok := value.(float64)\nfmt.Println(flo, ok)\n// 0 false\n```","x":-1500,"y":-680,"width":780,"height":640},
		{"id":"c1fd7b8dbb722ef3","type":"text","text":"### **Переключатель типа**\n\nПриведение типа можно использовать вместе со `switch`. Такая конструкция называется _переключателем типа_ (type switch):\n\n```go\nvar value any = \"hello\"\n\nswitch v := value.(type) {\ncase string:\n    fmt.Printf(\"%#v is a string\\\\n\", v)\ncase float64:\n    fmt.Printf(\"%#v is a float\\\\n\", v)\ndefault:\n    fmt.Printf(\"%#v is a mystery\\\\n\", v)\n}\n// \"hello\" is a string\n```\n\n`v` внутри сработавшей ветки переключателя имеет конкретный тип вместо `any` (в примере — `string`).","x":-1389,"y":240,"width":559,"height":500},
		{"id":"26fd1bbc324c8f02","type":"text","text":"Пока интерфейсной переменной не присвоено значение, у нее и `type`, и `value` равны `nil`, поэтому сама переменная считается равной `nil`:\n\n```go\nvar ivar any\n// type == nil, value == nil\n// поэтому ivar == nil\nfmt.Println(ivar == nil)\n// true\n```\n\nНо как только интерфейсной переменной присвоили значение, `type` перестает быть `nil`. Поэтому переменная больше не равна `nil`, даже если `value` равно `nil`:\n\n```go\nvar e *english\nfmt.Println(e == nil)\n// true\n\nivar = e\n// type == *english, value == nil\n// поскольку type != nil, то ivar != nil\nfmt.Println(ivar == nil)\n// false\n```\n","x":1500,"y":-378,"width":569,"height":620},
		{"id":"70bd167ad80fb388","type":"text","text":"Пока интерфейсная переменная равна `nil`, вызвать метод на ней не получится (ведь `type` неизвестен):\n\n```go\nvar ivar greeter\nivar.greet()\n// panic: runtime error: invalid memory address or nil pointer dereference\n```\n\nНо когда тип известен — вызвать метод на интерфейсной переменной можно, даже если `value` равно `nil`. Поэтому в методах стоит учитывать, что получатель может быть `nil`:\n\n```go\ntype greeter interface {\n    greet()\n}\n\ntype english struct {\n    name string\n}\n\n// e может быть nil!\nfunc (e *english) greet() {\n    if e == nil {\n        fmt.Println(\"I'm nil :(\")\n        return\n    }\n    fmt.Println(\"Hello\", e.name)\n}\n\nvar ivar greeter\nivar = (*english)(nil)\nivar.greet()\n// I'm nil :(\n```\n\nЭто контринтуитивная штука, поэтому ее имеет смысл запомнить.","x":1482,"y":372,"width":605,"height":848},
		{"id":"6d543d5c340e1702","type":"text","text":"Для работы с кэшами, когда обмен сообщениями, приведение к любому типу","x":652,"y":160,"width":297,"height":118},
		{"id":"a5c4b2a26da44cab","type":"text","text":"#### **Пустой интерфейс (`interface{}`):**\n\n- **Представляет значение любого типа.**\n- Используется для универсальности (например, если тип данных заранее неизвестен).\n- **Занимает 16 байт памяти** (на 64-битных системах): 8 байт для типа и 8 байт для данных.\n- Динамический, требует проверки или приведения типа.\n\n#### **Пустая структура (`struct{}`):**\n\n- **Не содержит данных и полей.**\n- Используется для сигналов или оптимизации (например, для экономии памяти или в качестве маркеров).\n- **Занимает 0 байт памяти.**\n- Статический, не требует приведения типа.\n\n---\n\n### **Главное отличие:**\n\n- **Пустой интерфейс** предназначен для хранения **любого значения**.\n- **Пустая структура** ничего не хранит и используется для указания факта или состояния (например, как маркер).","x":980,"y":-1260,"width":402,"height":845},
		{"id":"f2de5b253320486e","type":"text","text":"```go\nn, ok := i.(int)\nif ok {\n    fmt.Println(\"Это int:\", n)\n} else {\n    fmt.Println(\"Это не int\")\n}\n\n```","x":370,"y":-822,"width":380,"height":220},
		{"id":"5573c79dab7d8492","type":"text","text":"Структура интерфейса имеет всего два поля: \n1. указатель на тип (type)\n2. указатель на само значение (value)\n\ninterface{} == nil - сравнивает type","x":199,"y":-442,"width":361,"height":200}
	],
	"edges":[
		{"id":"17085341261cad15","fromNode":"2634770710bee2d0","fromSide":"top","toNode":"43f8384732693ac7","toSide":"bottom","label":"пояснение"},
		{"id":"e888df19f048d9cd","fromNode":"2634770710bee2d0","fromSide":"bottom","toNode":"4b401c09e391cea3","toSide":"top","label":"для чего?"},
		{"id":"1348a8f775a228e6","fromNode":"2634770710bee2d0","fromSide":"right","toNode":"ee9c04de9938e8d3","toSide":"left","label":"пустой интерфейс"},
		{"id":"6d94b1fb63197b9e","fromNode":"ee9c04de9938e8d3","fromSide":"top","toNode":"6c4977ee3704f79b","toSide":"bottom","label":"any"},
		{"id":"5fc197968cb3edb9","fromNode":"2634770710bee2d0","fromSide":"left","toNode":"a0faed38ce7d4d1c","toSide":"right","label":"приведение типов"},
		{"id":"93ec7e29d8ceb4d0","fromNode":"a0faed38ce7d4d1c","fromSide":"bottom","toNode":"c1fd7b8dbb722ef3","toSide":"top","label":"переключатель/switch"},
		{"id":"0da3f92129617e67","fromNode":"ee9c04de9938e8d3","fromSide":"right","toNode":"26fd1bbc324c8f02","toSide":"left","label":"nil в пустом интерфейсе"},
		{"id":"3e9ad3c95208a044","fromNode":"26fd1bbc324c8f02","fromSide":"bottom","toNode":"70bd167ad80fb388","toSide":"top","label":"методы с пустым интерфейсом"},
		{"id":"1df61ca40cf20d85","fromNode":"2634770710bee2d0","fromSide":"top","toNode":"5573c79dab7d8492","toSide":"bottom","label":"что внутри"},
		{"id":"4856e5d35405883c","fromNode":"ee9c04de9938e8d3","fromSide":"bottom","toNode":"6d543d5c340e1702","toSide":"top","label":"для чего"},
		{"id":"5c3d1fc7a3ae9fc3","fromNode":"ee9c04de9938e8d3","fromSide":"right","toNode":"a5c4b2a26da44cab","toSide":"bottom"},
		{"id":"90c5c9c6941e6cf4","fromNode":"5573c79dab7d8492","fromSide":"top","toNode":"f2de5b253320486e","toSide":"bottom","label":"type assertion"}
	]
}