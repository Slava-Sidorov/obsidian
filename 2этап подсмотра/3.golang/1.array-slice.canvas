{
	"nodes":[
		{"id":"960af62b88786b2e","type":"text","text":"array-slice","x":-161,"y":-8,"width":141,"height":60},
		{"id":"1f834c7cb0e0888f","type":"text","text":"Слайс в golang -  это обёртка над массивом. Слайс имеет нефиксированную длину, которая может изменяться в процессе работы с ним. ","x":254,"y":-100,"width":326,"height":160},
		{"id":"bb9ab4b2ce3cd658","type":"text","text":"Слайс можно передавать в функции по значению, но при этом изменение элементов слайса в функции отразится на исходном слайсе, так как они ссылаются на один и тот же массив.","x":-232,"y":260,"width":284,"height":240},
		{"id":"0e0041fa4e361144","type":"text","text":"Слайсом можно манипулировать с помощью различных операций и функций. Например, можно получать подслайсы с помощью оператора [:], добавлять элементы в конец слайса с помощью функции append, копировать элементы из одного слайса в другой с помощью функции copy, сортировать элементы слайса с помощью функции sort, и так далее.","x":-1160,"y":-81,"width":426,"height":267},
		{"id":"9f4ac281748eb716","type":"text","text":"Массив имеет фиксированный размер, который определяется при его создании. Слайс имеет переменную длину, которая может изменяться в процессе работы с ним.\n- Массив является значением, а слайс - ссылкой. При передаче массива в функцию или присваивании его другой переменной, происходит копирование всех его элементов. При передаче слайса в функцию или присваивании его другой переменной, происходит копирование только его заголовка, а не элементов.\n- Массив можно сравнивать с другим массивом того же размера и типа с помощью оператора ==. Слайс нельзя сравнивать с другим слайсом с помощью оператора ==, только с nil.\n- Массив можно инициализировать с помощью литерала массива, указав его размер и элементы в фигурных скобках. Слайс можно инициализировать с помощью литерала слайса, не указывая его размер, или с помощью функции make, указав его длину и вместимость","x":480,"y":-740,"width":840,"height":340},
		{"id":"cc7681e3a63ccf1e","type":"text","text":"Функция append работает таким образом, что если вместимость исходного слайса достаточна для добавления новых элементов, то она просто копирует их в свободное пространство массива, на который ссылается слайс. \n\nЕсли же вместимость исходного слайса недостаточна, то функция append выделяет новый массив большего размера, копирует в него все элементы исходного слайса и добавляет новые элементы. Затем функция append возвращает новый слайс, который ссылается на новый массив.\n","x":-1133,"y":482,"width":399,"height":398},
		{"id":"4b2d096bc0530a38","type":"text","text":"При перевыделении памяти, функция append следует определенной стратегии, чтобы избежать частого копирования и минимизировать оверхед. При текущем размере слайса менее 256 элементов, размер памяти увеличивается вдвое (вне зависимости от запрашиваемой cap). При размере слайса больше 256 элементов, слайс увеличивается на четверть текущего размера.","x":-1320,"y":-700,"width":469,"height":246},
		{"id":"7e3c115eb8297459","type":"text","text":"Если мы берем от слайса слайс, то его указатель будет указывать на тот же массив, что и указатель исходного слайса, но с другим смещением","x":840,"y":482,"width":355,"height":140},
		{"id":"8090d928aa3947a5","type":"text","text":"Скорость линейного поиска пропорциональна длине массива, то есть чем больше элементов в массиве, тем дольше будет идти поиск. Сложность линейного поиска в худшем случае составляет O(n), где n - это количество элементов в массиве.","x":-800,"y":-800,"width":455,"height":157},
		{"id":"dd7ac1d62aa07077","type":"text","text":"Такая работа может быть допустима, если соблюдены определенные условия и предосторожности:\n- Во-первых, конкуррентное чтение слайса не представляет опасности, если никто не пишет в слайс в то же время. То есть, можно безопасно читать слайс из нескольких горутин, если слайс не изменяется.\n- Во-вторых, конкуррентная запись в слайс может привести к гонке данных (data race), если не использовать синхронизацию или атомарные операции.\n\nДля предотвращения гонки данных, можно использовать один из следующих способов:\n\n- Использовать мьютекс sync.Mutex или sync.RWMutex для защиты слайса от одновременного доступа. \n- Использовать атомарные операции (sync/atomic) для изменения отдельных элементов слайса.\n- Использовать каналы для передачи слайса между горутинами.","x":520,"y":-1500,"width":638,"height":500},
		{"id":"4f4f8324a2e98fc4","type":"text","text":"```go\ntype slice struct {\n\tarray unsafe.Pointer\n\tlen   int\n\tcap   int\n}\n```","x":880,"y":-52,"width":297,"height":172},
		{"id":"7bfe7d638c6f81b7","type":"text","text":"Слайс в golang -  это обёртка над массивом(при обычном создании cap = len). Слайс имеет нефиксированную длину, которая может изменяться в процессе работы с ним. Слайс можно создавать из массивов, с помощью функции make или литералов слайсов.\n(при обычном создании cap = len)","x":-290,"y":-400,"width":400,"height":240},
		{"id":"eb4d282109414a03","type":"text","text":"Если вместимости недостаточно, то вывод метода не поможет","x":-1078,"y":1120,"width":289,"height":115},
		{"id":"442ec9cf31890e64","type":"text","text":"Слайс не может содержать элементы разных типов, только одного. Для хранения элементов разных типов нужно использовать структуры, интерфейсы или пустые интерфейсы (interface{}).\n- Слайс не может быть сравнен с другим слайсом с помощью оператора ==, только с nil. Для сравнения двух слайсов нужно использовать цикл или функцию reflect.DeepEqual.\n- Слайс не может быть использован в качестве ключа мапы, так как он не является хешируемым типом. Для использования слайса в качестве ключа мапы нужно преобразовать его в строку или другой хешируемый тип.\n- Слайс не может быть константой, так как он является ссылочным типом. Для объявления слайса нужно использовать var, := или make.\n- Слайс не может быть безопасно передан в функцию или возвращен из функции, так как он ссылается на массив, который может быть изменен в другом месте. Для безопасной передачи или возврата слайса нужно копировать его элементы в новый слайс с помощью функции copy или среза [:].","x":-345,"y":-1400,"width":523,"height":600},
		{"id":"c66cb055de763abb","x":-1620,"y":-340,"width":280,"height":211,"type":"text","text":"**Синтаксис:** `s[a:b]` или `s[a:b:c]`\n1. `s[a:b]`: длина = `b - a`, capacity = `cap(s) - a`\n2. `s[a:b:c]`: cap = `c - a` (явно задаётся)"},
		{"id":"42f438100fa613e5","x":-1620,"y":260,"width":400,"height":222,"type":"text","text":"- Предварительное выделение make([]T, 0, N) — минимизирует аллокации.\n-  Использование copy() вместо append в горячем коде.\n- Избегать \"memory leak\" при срезе больших массивов: b := append([]T(nil), a[:]...)."},
		{"id":"b6420946ab74bed3","x":-2240,"y":-180,"width":525,"height":400,"type":"text","text":"#### `s = s[:0]`\n- Обнуляет длину, **не трогает cap**.\n- Эффективен для **повторного использования** без выделения памяти.\n- Старые данные остаются в памяти (могут быть перезаписаны).\n#### `s = nil`\n- Обнуляет ссылку на массив.\n- `len(s) == 0`, `cap(s) == 0`, `s == nil` → может использоваться как \"пустое значение\"."}
	],
	"edges":[
		{"id":"b30a433416c689f5","fromNode":"960af62b88786b2e","fromSide":"top","toNode":"7bfe7d638c6f81b7","toSide":"bottom","label":"пояснение"},
		{"id":"93fd7ab45a6f6c11","fromNode":"960af62b88786b2e","fromSide":"right","toNode":"1f834c7cb0e0888f","toSide":"left","label":"под капотом"},
		{"id":"659407fd361514a9","fromNode":"960af62b88786b2e","fromSide":"bottom","toNode":"bb9ab4b2ce3cd658","toSide":"top","label":"передача в метод/функцию"},
		{"id":"bedc3fd563201814","fromNode":"960af62b88786b2e","fromSide":"left","toNode":"0e0041fa4e361144","toSide":"right","label":"что можно делать"},
		{"id":"aeabc564df65f67b","fromNode":"960af62b88786b2e","fromSide":"top","toNode":"9f4ac281748eb716","toSide":"bottom","label":"отличие массива от слайса"},
		{"id":"3c793eb2a8f62b20","fromNode":"0e0041fa4e361144","fromSide":"bottom","toNode":"cc7681e3a63ccf1e","toSide":"top","label":"append"},
		{"id":"b9740ebd45b0bd48","fromNode":"960af62b88786b2e","fromSide":"top","toNode":"4b2d096bc0530a38","toSide":"bottom","label":"расширение слайса"},
		{"id":"5de0c8e4adf990bc","fromNode":"960af62b88786b2e","fromSide":"bottom","toNode":"7e3c115eb8297459","toSide":"top","label":"Берём от слайса слайс, куда указывает?"},
		{"id":"c41d39dbea72287b","fromNode":"7bfe7d638c6f81b7","fromSide":"top","toNode":"442ec9cf31890e64","toSide":"bottom","label":"ограничения"},
		{"id":"068a8cfa338ab821","fromNode":"cc7681e3a63ccf1e","fromSide":"bottom","toNode":"eb4d282109414a03","toSide":"top","label":"увеличения slice в функции"},
		{"id":"2e6d07aecdb1af4b","fromNode":"7bfe7d638c6f81b7","fromSide":"left","toNode":"8090d928aa3947a5","toSide":"bottom","label":"сложность"},
		{"id":"b5460ab9297a6d4b","fromNode":"7bfe7d638c6f81b7","fromSide":"right","toNode":"dd7ac1d62aa07077","toSide":"left","label":"конкурентность"},
		{"id":"3ec76afe895e5ed5","fromNode":"1f834c7cb0e0888f","fromSide":"right","toNode":"4f4f8324a2e98fc4","toSide":"left","label":"структура"},
		{"id":"72785afe0657d86c","fromNode":"0e0041fa4e361144","fromSide":"left","toNode":"42f438100fa613e5","toSide":"top","label":"Методы оптимизации"},
		{"id":"d8732014f06f2db1","fromNode":"0e0041fa4e361144","fromSide":"left","toNode":"c66cb055de763abb","toSide":"right","label":"Реслайсинг"},
		{"id":"28e1ca442e9805c0","fromNode":"0e0041fa4e361144","fromSide":"left","toNode":"b6420946ab74bed3","toSide":"right","label":"Очистка"}
	]
}